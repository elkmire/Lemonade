<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="no-referrer">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=()">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Lemonade">
    <link rel="icon" href="icon.svg">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="manifest" href="manifest.json">
    <title>Lemonade</title>
    <style>
        /* CSS with dark/light mode support */
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --title-gradient: linear-gradient(90deg, #000000, #000000);
            --card-bg: #ffffff;
            --accent-color: #000000;
            --border-color: #dddddd;
            --input-bg: #ffffff;
            --button-bg: #000000;
            --button-text: #ffffff;
            --button-hover: #333333;
            --success-color: #00cc66;
            --error-color: #cc3300;
            --warning-color: #f0ad4e;
            --cyber-line: rgba(0, 0, 0, 0.15);
            --cyber-glow: rgba(0, 0, 0, 0.4);
            --security-high: #00cc66;
            --security-medium: #f0ad4e;
            --security-low: #cc3300;
        }

        /* Dark mode class */
        body.dark-mode {
            --bg-color: #000000;
            --text-color: #ffffff;
            --title-gradient: linear-gradient(90deg, #FF00FF, #00FFFF, #FFFF00);
            --card-bg: rgba(18, 18, 18, 0.7);
            --accent-color: #FF00FF; /* Neon Pink */
            --border-color: #333333;
            --input-bg: rgba(26, 26, 26, 0.7);
            --button-bg: #00FFFF; /* Neon Teal */
            --button-text: #000000;
            --button-hover: #FF00FF; /* Neon Purple */
            --success-color: #39FF14; /* Neon Green */
            --error-color: #FF3131; /* Neon Red */
            --warning-color: #FFFF00; /* Neon Yellow */
            --cyber-line: rgba(0, 255, 255, 0.4); /* Brighter Neon Teal */
            --cyber-glow: rgba(255, 0, 255, 0.6); /* Brighter Neon Purple */
            --security-high: #39FF14; /* Neon Green */
            --security-medium: #FFFF00; /* Neon Yellow */
            --security-low: #FF3131; /* Neon Red */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            display: none;
        }

        /* Psychedelic Background */
        body.dark-mode::before {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(
                125deg,
                #000000,
                #220033,
                #000033,
                #330033,
                #000022
            );
            background-size: 400% 400%;
            animation: gradient-shift 15s ease infinite;
            opacity: 0.9;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Add scanlines overlay */
        body.dark-mode::after {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }

        /* Enhanced App Title */
        body.dark-mode .app-title {
            background: var(--title-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px var(--cyber-glow);
            animation: title-shift 5s ease infinite;
        }

        @keyframes title-shift {
            0% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(90deg); }
            100% { filter: hue-rotate(0deg); }
        }

        /* Enhanced Cards with Glowing Borders */
        body.dark-mode .card {
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
            backdrop-filter: blur(5px);
            animation: border-pulse 4s infinite;
        }

        @keyframes border-pulse {
            0% { border-color: #FF00FF; box-shadow: 0 0 15px rgba(255, 0, 255, 0.5); }
            33% { border-color: #00FFFF; box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
            66% { border-color: #FFFF00; box-shadow: 0 0 15px rgba(255, 255, 0, 0.5); }
            100% { border-color: #FF00FF; box-shadow: 0 0 15px rgba(255, 0, 255, 0.5); }
        }

        /* Enhanced Buttons with Glow Effect */
        body.dark-mode button {
            border: 1px solid transparent;
            box-shadow: 0 0 10px var(--cyber-glow);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        body.dark-mode button:hover {
            box-shadow: 0 0 20px var(--cyber-glow);
            transform: translateY(-2px);
        }

        /* Psychedelic button effects */
        body.dark-mode button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                #FF00FF,
                #00FFFF,
                #FFFF00,
                #FF00FF
            );
            animation: rotate 3s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: -1;
        }

        body.dark-mode button:hover::before {
            opacity: 0.3;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Enhanced Input Fields */
        body.dark-mode input, 
        body.dark-mode textarea, 
        body.dark-mode select {
            border: 1px solid var(--border-color);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        body.dark-mode input:focus, 
        body.dark-mode textarea:focus, 
        body.dark-mode select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--cyber-glow), inset 0 0 10px rgba(0, 0, 0, 0.5);
            animation: focus-pulse 2s infinite;
        }

        @keyframes focus-pulse {
            0% { border-color: #FF00FF; }
            50% { border-color: #00FFFF; }
            100% { border-color: #FF00FF; }
        }

        /* Enhanced Security Badges */
        body.dark-mode .security-badge {
            animation: security-pulse 2s infinite;
            text-shadow: 0 0 5px currentColor;
        }

        @keyframes security-pulse {
            0% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 15px currentColor; }
            100% { box-shadow: 0 0 5px currentColor; }
        }

        /* Enhanced Key Items */
        body.dark-mode .key-item {
            border: 1px solid var(--border-color);
            background: linear-gradient(145deg, rgba(18, 18, 18, 0.7), rgba(26, 26, 26, 0.7));
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        body.dark-mode .key-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
        }

        /* Tab Button Enhancement */
        body.dark-mode .tab-btn.active {
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.5), rgba(255, 0, 255, 0.1), rgba(0, 0, 0, 0.5));
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
            animation: tab-shift 3s infinite;
        }

        @keyframes tab-shift {
            0% { border-color: #FF00FF; }
            33% { border-color: #00FFFF; }
            66% { border-color: #FFFF00; }
            100% { border-color: #FF00FF; }
        }

        /* Switch slider enhancement */
        body.dark-mode .slider {
            background: linear-gradient(90deg, #220033, #000033);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        body.dark-mode input:checked + .slider {
            background: linear-gradient(90deg, #00FFFF, #FF00FF);
        }

        body.dark-mode .slider:before {
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* Status enhancement */
        body.dark-mode .status.success,
        body.dark-mode .status.warning,
        body.dark-mode .status.error {
            animation: status-pulse 2s infinite;
        }

        @keyframes status-pulse {
            0% { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); }
            50% { box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5); }
            100% { box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); }
        }

        /* Loading animation enhancement */
        body.dark-mode .spinner {
            border: 5px solid rgba(0, 0, 0, 0.3);
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite, color-shift 3s linear infinite;
        }

        @keyframes color-shift {
            0% { border-top-color: #FF00FF; }
            33% { border-top-color: #00FFFF; }
            66% { border-top-color: #FFFF00; }
            100% { border-top-color: #FF00FF; }
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .app-header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }
        
        .app-title {
            font-size: 1.8rem;
            margin: 0;
            background: var(--title-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px var(--cyber-glow);
        }

        .app-subtitle {
            font-size: 0.9rem;
            margin: 0;
            padding-top: 2px;
            font-style: italic;
            color: var(--text-color);
            opacity: 0.8;
        }
        
        .app-header::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #33aaff, #0066cc);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            color: var(--text-color);
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .tab-btn.active {
            border-bottom: 2px solid var(--accent-color);
            color: var(--accent-color);
        }
        
        .tab-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background-color: var(--accent-color);
            transition: width 0.3s;
        }
        
        .tab-btn:hover::after {
            width: 100%;
        }
        
        .tab-content {
            display: none !important;
        }
        
        .tab-content.active {
            display: block !important;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            box-sizing: border-box;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--cyber-glow);
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background-color: var(--button-hover);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }
        
        button:focus:not(:active)::after {
            animation: ripple 1s ease-out;
        }
        
        @keyframes ripple {
            0% { transform: scale(0, 0); opacity: 0.5; }
            100% { transform: scale(20, 20); opacity: 0; }
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
        }
        
        .btn-secondary:hover {
            background-color: rgba(51, 170, 255, 0.1);
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }
        
        .status.success {
            background-color: rgba(0, 204, 102, 0.1);
            color: var(--success-color);
            border: 1px solid var(--success-color);
            display: block;
        }
        
        .status.warning {
            background-color: rgba(240, 173, 78, 0.1);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
            display: block;
        }
        
        .status.error {
            background-color: rgba(204, 51, 0, 0.1);
            color: var(--error-color);
            border: 1px solid var(--error-color);
            display: block;
        }
        
        .key-item {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        
        .key-item h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .key-header {
            text-align: center;
            margin-bottom: 15px;
        }
        
        .key-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .key-meta {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 5px;
        }

        .btn-zero {
            background-color: #cc3300;
            color: white;
            margin-top: 20px;
            width: 100%;
            font-weight: bold;
            border: 1px solid #aa2200;
        }

        .btn-zero:hover {
            background-color: #ff3300;
        }

        /* Dark mode override to ensure it stays red */
        body.dark-mode .btn-zero {
            background-color: #ff3131; /* Neon Red */
            color: white;
            border: 1px solid #cc0000;
        }

        body.dark-mode .btn-zero:hover {
            background-color: #ff5555; /* Lighter Neon Red */
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .password-strength {
            height: 5px;
            border-radius: 5px;
            margin-top: 5px;
            transition: all 0.3s;
        }
        
        .password-strength.weak {
            background-color: var(--security-low);
            width: 30%;
        }
        
        .password-strength.medium {
            background-color: var(--security-medium);
            width: 60%;
        }
        
        .password-strength.strong {
            background-color: var(--security-high);
            width: 100%;
        }
        
        .password-feedback {
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        .security-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 8px;
            font-weight: bold;
        }
        
        .security-badge.high {
            background-color: rgba(0, 204, 102, 0.1);
            color: var(--security-high);
            border: 1px solid var(--security-high);
        }
        
        .security-badge.medium {
            background-color: rgba(240, 173, 78, 0.1);
            color: var(--security-medium);
            border: 1px solid var(--security-medium);
        }
        
        .security-badge.low {
            background-color: rgba(204, 51, 0, 0.1);
            color: var(--security-low);
            border: 1px solid var(--security-low);
        }

        /* Security badge pulse animation */
        @keyframes securityPulse {
            0% {
                box-shadow: 0 0 5px currentColor;
            }
            50% {
                box-shadow: 0 0 15px currentColor;
            }
            100% {
                box-shadow: 0 0 5px currentColor;
            }
        }

        /* Add pulsing effect to security badges in dark mode */
        body.dark-mode .security-badge {
            animation: securityPulse 2s infinite;
            transition: all 0.3s ease;
        }

        /* Enhanced colors for dark mode security badges */
        body.dark-mode .security-badge.high {
            box-shadow: 0 0 5px var(--security-high);
        }

        body.dark-mode .security-badge.medium {
            box-shadow: 0 0 5px var(--security-medium);
        }

        body.dark-mode .security-badge.low {
            box-shadow: 0 0 5px var(--security-low);
        }

        .key-pair-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 5px;
        }

        .key-pair-badge.full {
            background-color: rgba(0, 204, 102, 0.1);
            color: var(--security-high);
            border: 1px solid var(--security-high);
        }

        .key-pair-badge.private {
            background-color: rgba(204, 51, 0, 0.1);
            color: var(--security-low);
            border: 1px solid var(--security-low);
        }

        .key-pair-badge.public {
            background-color: rgba(240, 173, 78, 0.1);
            color: var(--security-medium);
            border: 1px solid var(--security-medium);
        }

        .private-key-btn {
            border: 1px solid var(--error-color) !important;
            color: var(--error-color) !important;
        }

        .private-key-btn:hover {
            background-color: rgba(204, 51, 0, 0.1) !important;
        }

        /* Enhanced colors for dark mode key pair badges */
        body.dark-mode .key-pair-badge.full {
            box-shadow: 0 0 5px var(--security-high);
        }

        body.dark-mode .key-pair-badge.private {
            box-shadow: 0 0 5px var(--security-low);
        }

        body.dark-mode .key-pair-badge.public {
            box-shadow: 0 0 5px var(--security-medium);
        }

        body.dark-mode .private-key-btn {
            border: 1px solid var(--error-color) !important;
            color: var(--error-color) !important;
        }

        body.dark-mode .private-key-btn:hover {
            background-color: rgba(255, 49, 49, 0.2) !important;
        }
        
        .config-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .config-toggle label {
            display: inline;
            margin-bottom: 0;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--accent-color);
        }
        
        input:focus + .slider {
            box-shadow: 0 0 1px var(--accent-color);
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .security-info {
            font-size: 0.9rem;
            padding: 10px;
            border-left: 3px solid var(--accent-color);
            background-color: rgba(51, 170, 255, 0.05);
            margin-bottom: 15px;
        }
        
        .key-expiry {
            font-size: 0.8rem;
            color: var(--warning-color);
            margin-top: 5px;
            font-style: italic;
        }
        
        #inactivityModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1001;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            text-align: center;
        }
        
        .timer {
            font-size: 2rem;
            margin: 20px 0;
            color: var(--warning-color);
        }
        
        /* Additional settings section */
        #settings {
            display: none;
        }
        
        .settings-section {
            margin-bottom: 20px;
        }
        
        .settings-section h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            .card {
                padding: 15px;
            }
            
            .app-title {
                font-size: 1.5rem;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
            
            .tab-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
        }

    .file-info {
        margin-top: 10px;
        font-size: 0.9rem;
        background-color: var(--input-bg);
        padding: 8px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .file-info-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .file-icon {
        margin-right: 8px;
        font-size: 1.2rem;
    }

    .remove-file {
        cursor: pointer;
        color: var(--error-color);
        padding: 2px 6px;
        border-radius: 4px;
        margin-left: 8px;
    }

    .remove-file:hover {
        background-color: rgba(204, 51, 0, 0.1);
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="app-header">
            <h1 class="app-title">Lemonade</h1>
            <div class="app-subtitle">by elkmire</div>
            <p>The offline security method</p>
        </div>
        
        <div class="tabs">
            <button class="tab-btn active" data-tab="encrypt">Encrypt</button>
            <button class="tab-btn" data-tab="decrypt">Decrypt</button>
            <button class="tab-btn" data-tab="keys">Key Management</button>
            <button class="tab-btn" data-tab="settings">Settings</button>
        </div>
        
        <div class="tab-content active" id="encrypt">
            <div class="card">
                <div class="form-group">
                    <label for="encryptMessage">To Encrypt</label>
                    <textarea id="encryptMessage" placeholder="Free-type here or load file for encryption..."></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <button id="encryptBrowseBtn" class="btn-secondary">Browse Files</button>
                        <button id="clearEncryptMessageBtn" class="btn-secondary">Clear</button>
                        <input type="file" id="encryptFileInput" style="display: none;">
                    </div>
                    <div id="encryptFileInfo" style="display: none;" class="file-info">
                        <span><span class="file-icon">ðŸ“„</span> <span id="encryptFileName" class="file-info-name"></span></span>
                        <span class="remove-file" id="removeEncryptFile">Ã—</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="encryptionKey">Encryption Key</label>
                    <select id="encryptionKey">
                        <option value="">Select a key...</option>
                    </select>
                </div>
                
                <div class="form-group" id="encryptionPasswordGroup" style="display: none;">
                    <label for="encryptionPassword">Key Password</label>
                    <input type="password" id="encryptionPassword" placeholder="Enter key password">
                </div>
                
                <button id="encryptBtn">Encrypt Data</button>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label for="encryptedOutput">Encrypted Data</label>
                    <textarea id="encryptedOutput" readonly></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="downloadEncryptedBtn" class="btn-secondary">Download Encrypted File</button>
                    <button id="copyEncryptedBtn" class="btn-secondary">Copy to Clipboard</button>
                    <button id="clearEncryptBtn" class="btn-secondary">Clear All</button>
                </div>
                
                <div id="encryptStatus" class="status"></div>
            </div>
        </div>
        
        <div class="tab-content" id="decrypt">
            <div class="card">
                <div class="form-group">
                    <label for="encryptedMessage">To Decrypt</label>
                    <textarea id="encryptedMessage" placeholder="Paste the encrypted data here or load encrypted data..."></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <button id="decryptBrowseBtn" class="btn-secondary">Browse Files</button>
                        <button id="clearEncryptedMessageBtn" class="btn-secondary">Clear</button>
                        <input type="file" id="decryptFileInput" style="display: none;">
                    </div>
                    <div id="decryptFileInfo" style="display: none;" class="file-info">
                        <span><span class="file-icon">ðŸ“„</span> <span id="decryptFileName" class="file-info-name"></span></span>
                        <span class="remove-file" id="removeDecryptFile">Ã—</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="decryptionKey">Decryption Key</label>
                    <select id="decryptionKey">
                        <option value="">Select a key...</option>
                    </select>
                </div>
                
                <div class="form-group" id="decryptionPasswordGroup" style="display: none;">
                    <label for="decryptionPassword">Key Password</label>
                    <input type="password" id="decryptionPassword" placeholder="Enter key password">
                </div>
                
                <button id="decryptBtn">Decrypt Data</button>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label for="decryptedOutput">Decrypted Data</label>
                    <textarea id="decryptedOutput" readonly></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="downloadDecryptedBtn" class="btn-secondary">Download Decrypted File</button>
                    <button id="copyDecryptedBtn" class="btn-secondary">Copy to Clipboard</button>
                    <button id="clearDecryptBtn" class="btn-secondary">Clear All</button>
                </div>
                
                <div id="decryptStatus" class="status"></div>
            </div>
        </div>
        
        <div class="tab-content" id="keys">
            <div class="card">
                <h2>Key Management</h2>
                
                <div class="security-info">
                    <strong>Security Note:</strong> All keys are stored locally in your browser's protected storage and never sent to any server.
                </div>
                
                <div class="form-group">
                    <label for="keyName">Key Name</label>
                    <input type="text" id="keyName" placeholder="e.g., enter crypto name">
                </div>
                
                <div class="form-group">
                    <label for="keyType">Key Type</label>
                    <select id="keyType">
                        <option value="aes">AES-GCM (Symmetric) - 256 bits</option>
                        <option value="rsa">RSA-OAEP (Asymmetric) - 2048 bits</option>
                        <option value="rsa-4096">RSA-OAEP (Asymmetric) - 4096 bits</option>
                        <option value="ecc">ECC (Asymmetric) - P-256</option>
                        <option value="ecc-p384">ECC (Asymmetric) - P-384</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="keyExpiry">Key Expiration (Optional)</label>
                    <select id="keyExpiry">
                        <option value="">Never (Not Recommended)</option>
                        <option value="30">30 Days</option>
                        <option value="90">90 Days</option>
                        <option value="180">180 Days</option>
                        <option value="365">1 Year</option>
                    </select>
                </div>
                
                <div class="form-group" id="keyPasswordGroup">
                    <label for="keyPassword">Key Password (Recommended)</label>
                    <input type="password" id="keyPassword" placeholder="Enter optional password">
                    <div id="passwordStrength" class="password-strength"></div>
                    <div id="passwordFeedback" class="password-feedback"></div>
                </div>
                
                <div class="form-group" id="confirmKeyPasswordGroup">
                    <label for="confirmKeyPassword">Confirm Password</label>
                    <input type="password" id="confirmKeyPassword" placeholder="Confirm your password">
                </div>
                
                <button id="generateKeyBtn">Generate New Key</button>
                
                <div style="margin-top: 30px;">
                    <h3>Your Keys</h3>
                    <div id="keysList">
                        <!-- Keys will be populated here -->
                    </div>
                </div>
                
                <div class="btn-group">
                    <button id="importKeyBtn" class="btn-secondary">Import Key</button>
                    <button id="exportAllKeysBtn" class="btn-secondary">Export State</button>
                    <button id="importStateBtn" class="btn-secondary">Import State</button>
                </div>

                <div style="text-align: center;">
                    <button id="zeroKeysBtn" class="btn-zero">ZERO ALL KEYS</button>
                </div>
                
                <div id="keyStatus" class="status"></div>
            </div>
        </div>
        
        <div class="tab-content" id="settings">
            <div class="card">
                <h2>Security Settings</h2>
<p> (Must SAVE for changes to take effect) <p>
                
                <div class="settings-section">
                    <h3>Storage Options</h3>
                    
                    <div class="config-toggle">
                        <label for="useIndexedDB">Use IndexedDB for key storage (more secure)</label>
                        <label class="switch">
                            <input type="checkbox" id="useIndexedDB" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="config-toggle">
                        <label for="sessionOnly">Session-only mode (keys aren't saved when browser closes)</label>
                        <label class="switch">
                            <input type="checkbox" id="sessionOnly">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>Security Parameters</h3>
                    
                    <div class="config-toggle">
                        <label for="enforcePwdProtection">Enforce password protection for keys</label>
                        <label class="switch">
                            <input type="checkbox" id="enforcePwdProtection">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="config-toggle">
                        <label for="enforceKeyExpiry">Enforce key expiration</label>
                        <label class="switch">
                            <input type="checkbox" id="enforceKeyExpiry">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label for="pbkdf2Iterations">PBKDF2 Iterations (higher = more secure but slower)</label>
                        <select id="pbkdf2Iterations">
                            <option value="100000">100,000 (Default)</option>
                            <option value="200000">200,000</option>
                            <option value="300000">300,000</option>
                            <option value="500000">500,000</option>
                        </select>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Appearance</h3>
                    
                    <div class="config-toggle">
                        <label for="darkMode">Dark Mode</label>
                        <label class="switch">
                            <input type="checkbox" id="darkMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Install App</h3>
                    <p>Installs PWA (must be Chromium-based browser or Safari for IOS)</p>
                    <div id="installContainer">
                        <button id="installBtn" class="btn-secondary">Install Lemonade App</button>
                        <p class="install-note" style="margin-top: 8px; font-size: 0.85rem; color: #888;">
                            (Button will be enabled when installation is available)
                        </p>
                    </div>
                    <div id="installStatus" class="status"></div>
                </div>

                <div class="btn-group">
                    <button id="saveSettingsBtn">Save Settings</button>
                    <button id="resetSettingsBtn" class="btn-secondary">Reset to Defaults</button>
                </div>
                
                <div id="settingsStatus" class="status"></div>
            </div>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
    </div>
    
    <script>
        // Secure Constants with proper bits for each algorithm
        const PBKDF2_CONFIG = {
            ITERATIONS: 100000,
            HASH: "SHA-256"
        };
        const AES_CONFIG = {
            KEY_LENGTH: 256,
            MODE: "AES-GCM",
            IV_LENGTH: 12, // bytes
            TAG_LENGTH: 128 // bits
        };
        const RSA_CONFIG = {
            KEY_SIZE: 2048,
            KEY_SIZE_4096: 4096,
            ALGORITHM: "RSA-OAEP",
            HASH: "SHA-256"
        };
        const ECC_CONFIG = {
            CURVE: "P-256",
            CURVE_P384: "P-384",
            ALGORITHM: "ECDH",
            KEY_DERIVATION: "HKDF",
            KDF_HASH: "SHA-256",
            ENC_ALGORITHM: "AES-GCM"
        };
        
        // DB Constants
        const DB_NAME = "LemonadeSecureDB";
        const DB_VERSION = 1;
        const KEYS_STORE = "keys";
        const SETTINGS_STORE = "settings";
        
        // Security settings default values
        const DEFAULT_SETTINGS = {
            useIndexedDB: true,
            sessionOnly: false,
            enforcePwdProtection: false,
            enforceKeyExpiry: false,
            pbkdf2Iterations: 100000,
        };
        
        // Global variables
        let db = null;
        let keys = [];
        let appSettings = { ...DEFAULT_SETTINGS };
        
        // Elements
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        const encryptionKeySelect = document.getElementById('encryptionKey');
        const decryptionKeySelect = document.getElementById('decryptionKey');
        const keysList = document.getElementById('keysList');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const inactivityModal = document.getElementById('inactivityModal');
        const timeoutTimer = document.getElementById('timeoutTimer');
        
        // Memory protection and content validation utilities
        const safeMemory = {
            // Create a WeakMap to store sensitive data with automatic garbage collection
            sensitiveData: new WeakMap(),
            
            // Store sensitive data with a random key
            store: function(data) {
                const secureKey = { id: crypto.randomUUID() };
                this.sensitiveData.set(secureKey, data);
                return secureKey;
            },
            
            // Retrieve and optionally delete sensitive data
            retrieve: function(secureKey, deleteAfter = false) {
                if (!this.sensitiveData.has(secureKey)) return null;
                
                const data = this.sensitiveData.get(secureKey);
                
                if (deleteAfter) {
                    this.sensitiveData.delete(secureKey);
                }
                
                return data;
            },
            
            // Explicitly delete sensitive data
            delete: function(secureKey) {
                if (this.sensitiveData.has(secureKey)) {
                    this.sensitiveData.delete(secureKey);
                    return true;
                }
                return false;
            },
            
            // Securely clear all sensitive data
            clearAll: function() {
                this.sensitiveData = new WeakMap();
                // Force garbage collection if possible (not guaranteed)
                if (typeof window.gc === 'function') {
                    try {
                        window.gc();
                    } catch (e) {
                        console.log('Manual garbage collection not available');
                    }
                }
            }
        };
        
        const validator = {
            sanitizeHTML: function(text) {
                const element = document.createElement('div');
                element.textContent = text;
                return element.innerHTML;
            },
            
            validateInput: function(input, allowHTML = false) {
                // Reject null or undefined
                if (input === null || input === undefined) return '';
                
                // Convert to string if not already
                const str = String(input);
                
                // Return sanitized or raw based on allowHTML
                return allowHTML ? str : this.sanitizeHTML(str);
            },
            
            isValidKeyName: function(name) {
                return /^[A-Za-z0-9 ._-]{1,50}$/.test(name);
            },
            
            isValidEncryptedMessage: function(message) {
                return /^--LM--\s*[A-Za-z0-9+/=]+\s*--EM--$/s.test(message);
            },
            
            measurePasswordStrength: function(password) {
                // Default score is 0 (weak)
                let score = 0;
                
                // Skip empty passwords
                if (!password) return { score: 0, feedback: "Password is required" };
                
                // Check length (up to 5 points)
                const length = password.length;
                score += Math.min(5, Math.floor(length / 4));
                
                // Check complexity (up to 5 more points)
                if (/[a-z]/.test(password)) score += 1; // Has lowercase
                if (/[A-Z]/.test(password)) score += 1; // Has uppercase
                if (/[0-9]/.test(password)) score += 1; // Has number
                if (/[^A-Za-z0-9]/.test(password)) score += 2; // Has special char
                
                // Check for common patterns (subtract points)
                if (/^[a-zA-Z]+$/.test(password)) score -= 1; // Letters only
                if (/^[0-9]+$/.test(password)) score -= 1; // Numbers only
                if (/(.)\1{2,}/.test(password)) score -= 1; // Repeated characters
                
                // Get strength category and feedback
                let strengthCategory, feedback;
                
                if (score < 4) {
                    strengthCategory = "weak";
                    feedback = "Weak - Use a longer password with numbers and special characters";
                } else if (score < 8) {
                    strengthCategory = "medium";
                    feedback = "Medium - Add more variety or length for better security";
                } else {
                    strengthCategory = "strong";
                    feedback = "Strong - Good password!";
                }
                
                return { score, strengthCategory, feedback };
            }
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Set up tabs - Using direct event binding for more reliable tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabId = btn.getAttribute('data-tab');
                    console.log('Tab button clicked:', tabId);
                    switchTab(tabId);
                });
            });

            // Setup dark mode toggle
            document.getElementById('darkMode').addEventListener('change', toggleDarkMode);
            // Check for saved theme preference
            const savedTheme = localStorage.getItem('LemonadeDarkMode');
            if (savedTheme === 'true') {
                document.getElementById('darkMode').checked = true;
                document.body.classList.add('dark-mode');
            }

            // Clear message buttons
            document.getElementById('clearEncryptMessageBtn').addEventListener('click', () => {
                clearEncryptFile(); 
            });
            document.getElementById('clearEncryptedMessageBtn').addEventListener('click', () => {
                clearDecryptFile(); 
            });
            
            // Set up database
            await initDatabase();
            
            // Load saved settings
            await loadSettings();
            
            // Initialize UI based on settings
            initSettingsUI();
            
            // Load stored keys
            await loadKeys();
            
            // Set up password strength meter
            document.getElementById('keyPassword').addEventListener('input', updatePasswordStrength);
            
            // Set up event listeners
            document.getElementById('encryptBtn').addEventListener('click', encryptMessage);
            document.getElementById('decryptBtn').addEventListener('click', decryptMessage);
            document.getElementById('generateKeyBtn').addEventListener('click', generateKey);
            document.getElementById('copyEncryptedBtn').addEventListener('click', () => copyToClipboard('encryptedOutput', 'encryptStatus'));
            document.getElementById('copyDecryptedBtn').addEventListener('click', () => copyToClipboard('decryptedOutput', 'decryptStatus'));
            document.getElementById('clearEncryptBtn').addEventListener('click', () => {
                document.getElementById('encryptMessage').value = '';
                document.getElementById('encryptedOutput').value = '';
                document.getElementById('encryptStatus').className = 'status';
                document.getElementById('encryptStatus').textContent = '';
                
                // Also clear any loaded files
                clearEncryptFile();
            });
            document.getElementById('clearDecryptBtn').addEventListener('click', () => {
                document.getElementById('encryptedMessage').value = '';
                document.getElementById('decryptedOutput').value = '';
                document.getElementById('decryptStatus').className = 'status';
                document.getElementById('decryptStatus').textContent = '';
                
                // Also clear any loaded files
                clearDecryptFile();
                
                // Clear any decrypted binary data if present
                window.decryptedBinaryData = null;
            });
            document.getElementById('importKeyBtn').addEventListener('click', importKey);
            document.getElementById('exportAllKeysBtn').addEventListener('click', exportAllKeys);
            document.getElementById('importStateBtn').addEventListener('click', importState);
            document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
            document.getElementById('resetSettingsBtn').addEventListener('click', resetSettings);
            document.getElementById('zeroKeysBtn').addEventListener('click', zeroAllKeys);
            
            // Key select changes
            encryptionKeySelect.addEventListener('change', handleEncryptionKeyChange);
            decryptionKeySelect.addEventListener('change', handleDecryptionKeyChange);

        });
        
        // Database Initialization
        async function initDatabase() {
            if (!window.indexedDB) {
                showStatus('keyStatus', 'Your browser doesn\'t support secure storage. Using less secure localStorage instead.', 'warning');
                appSettings.useIndexedDB = false;
                return;
            }
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains(KEYS_STORE)) {
                        db.createObjectStore(KEYS_STORE, { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                        db.createObjectStore(SETTINGS_STORE, { keyPath: 'id' });
                    }
                };
                
                request.onsuccess = function(event) {
                    db = event.target.result;
                    console.log('Database initialized successfully');
                    resolve();
                };
                
                request.onerror = function(event) {
                    console.error('Database error:', event.target.error);
                    showStatus('keyStatus', 'Database initialization failed. Using less secure localStorage instead.', 'warning');
                    appSettings.useIndexedDB = false;
                    resolve(); // Still resolve to continue app initialization
                };
            });
        }
        
        // Tab switching
        function switchTab(tabId) {
            console.log('Switching to tab:', tabId);
            
            // Update tab buttons
            tabBtns.forEach(btn => {
                if (btn.getAttribute('data-tab') === tabId) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Directly access each tab content by ID to ensure all tabs are handled
            document.getElementById('encrypt').classList.remove('active');
            document.getElementById('decrypt').classList.remove('active');
            document.getElementById('keys').classList.remove('active');
            document.getElementById('settings').classList.remove('active');
            
            // Set the selected tab to active
            document.getElementById(tabId).classList.add('active');
        }
        
        // Show/hide loading overlay
        function setLoading(isLoading) {
            loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        }
        
        // Settings Management
        async function loadSettings() {
            if (appSettings.useIndexedDB && db) {
                try {
                    const settings = await getFromDatabase(SETTINGS_STORE, 'app-settings');
                    if (settings) {
                        appSettings = { ...DEFAULT_SETTINGS, ...settings };
                    }
                } catch (error) {
                    console.error('Error loading settings from database:', error);
                    // Fall back to localStorage
                    try {
                        const storedSettings = localStorage.getItem('LemonadeSettings');
                        if (storedSettings) {
                            appSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
                        }
                    } catch (localStorageError) {
                        console.error('Error loading settings from localStorage:', localStorageError);
                    }
                }
            } else {
                // Use localStorage
                try {
                    const storedSettings = localStorage.getItem('LemonadeSettings');
                    if (storedSettings) {
                        appSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
                    }
                } catch (error) {
                    console.error('Error loading settings from localStorage:', error);
                }
            }
            
            // Update PBKDF2 iterations from settings
            PBKDF2_CONFIG.ITERATIONS = appSettings.pbkdf2Iterations;
            
            return appSettings;
        }
        
        function initSettingsUI() {
            // Set UI elements based on loaded settings
            document.getElementById('useIndexedDB').checked = appSettings.useIndexedDB;
            document.getElementById('sessionOnly').checked = appSettings.sessionOnly;
            document.getElementById('enforcePwdProtection').checked = appSettings.enforcePwdProtection;
            document.getElementById('enforceKeyExpiry').checked = appSettings.enforceKeyExpiry;
            document.getElementById('pbkdf2Iterations').value = appSettings.pbkdf2Iterations;
        }
        
        async function saveSettings() {
            try {
                // Get values from UI
                appSettings.useIndexedDB = document.getElementById('useIndexedDB').checked;
                appSettings.sessionOnly = document.getElementById('sessionOnly').checked;
                appSettings.enforcePwdProtection = document.getElementById('enforcePwdProtection').checked;
                appSettings.enforceKeyExpiry = document.getElementById('enforceKeyExpiry').checked;
                appSettings.pbkdf2Iterations = parseInt(document.getElementById('pbkdf2Iterations').value);
                
                // Update PBKDF2 iterations
                PBKDF2_CONFIG.ITERATIONS = appSettings.pbkdf2Iterations;
                
                // Save settings to database or localStorage
                if (appSettings.useIndexedDB && db) {
                    await saveToDatabase(SETTINGS_STORE, { id: 'app-settings', ...appSettings });
                } else {
                    localStorage.setItem('LemonadeSettings', JSON.stringify(appSettings));
                }
                
                showStatus('settingsStatus', 'Settings saved successfully', 'success');
            } catch (error) {
                console.error('Error saving settings:', error);
                showStatus('settingsStatus', 'Error saving settings: ' + error.message, 'error');
            }
        }
        
        function resetSettings() {
            const confirmReset = confirm('Are you sure you want to reset all settings to defaults?');
            if (!confirmReset) return;
            
            appSettings = { ...DEFAULT_SETTINGS };
            initSettingsUI();
            saveSettings();
        }
        
        // Password strength meter
        function updatePasswordStrength() {
            const password = document.getElementById('keyPassword').value;
            const strength = validator.measurePasswordStrength(password);
            
            const strengthElement = document.getElementById('passwordStrength');
            const feedbackElement = document.getElementById('passwordFeedback');
            
            // Clear existing classes
            strengthElement.className = 'password-strength';
            
            if (password) {
                // Add class based on strength
                strengthElement.classList.add(strength.strengthCategory);
                
                // Update feedback
                feedbackElement.textContent = strength.feedback;
            } else {
                feedbackElement.textContent = '';
            }
        }
        
        // Key Management Functions
        async function loadKeys() {
            try {
                // Clear existing keys
                keys = [];
                
                if (appSettings.useIndexedDB && db) {
                    // Load from IndexedDB
                    const storedKeys = await getAllFromDatabase(KEYS_STORE);
                    if (storedKeys && storedKeys.length > 0) {
                        keys = storedKeys;
                    }
                } else {
                    // Load from localStorage
                    const storedKeys = localStorage.getItem('LemonadeKeys');
                    if (storedKeys) {
                        keys = JSON.parse(storedKeys);
                    }
                }
                
                // Check for expired keys and update UI
                checkExpiredKeys();
                updateKeysList();
                updateKeySelects();
            } catch (error) {
                console.error('Error loading keys:', error);
                showStatus('keyStatus', 'Error loading keys: ' + error.message, 'error');
            }
        }
        
        async function saveKeys() {
            try {
                if (appSettings.sessionOnly) {
                    // In session-only mode, we keep keys in memory but don't persist them
                    console.log('Session-only mode: Keys not saved persistently');
                } else if (appSettings.useIndexedDB && db) {
                    // Save to IndexedDB - first clear the store
                    await clearDatabase(KEYS_STORE);
                    
                    // Then add all keys
                    for (const keyData of keys) {
                        await saveToDatabase(KEYS_STORE, keyData);
                    }
                } else {
                    // Save to localStorage
                    localStorage.setItem('LemonadeKeys', JSON.stringify(keys));
                }
                
                // Update UI
                updateKeysList();
                updateKeySelects();
            } catch (error) {
                console.error('Error saving keys:', error);
                showStatus('keyStatus', 'Error saving keys: ' + error.message, 'error');
            }
        }
        
        function checkExpiredKeys() {
            const now = new Date();
            const expiredKeyIds = [];
            
            // Check each key for expiration
            keys.forEach(keyData => {
                if (keyData.expiry) {
                    const expiryDate = new Date(keyData.expiry);
                    if (expiryDate < now) {
                        expiredKeyIds.push(keyData.id);
                    }
                }
            });
            
            // Remove expired keys
            if (expiredKeyIds.length > 0) {
                keys = keys.filter(key => !expiredKeyIds.includes(key.id));
                saveKeys();
                showStatus('keyStatus', `${expiredKeyIds.length} expired key(s) removed for security`, 'warning');
            }
        }
        
        async function generateKey() {
            try {
                setLoading(true);
                
                const keyName = document.getElementById('keyName').value.trim();
                const keyType = document.getElementById('keyType').value;
                const keyPassword = document.getElementById('keyPassword').value;
                const confirmKeyPassword = document.getElementById('confirmKeyPassword').value;
                const keyExpiry = document.getElementById('keyExpiry').value;
                
                // Validate key name
                if (!keyName) {
                    showStatus('keyStatus', 'Please enter a key name', 'error');
                    return;
                }
                
                if (!validator.isValidKeyName(keyName)) {
                    showStatus('keyStatus', 'Key name can only contain letters, numbers, spaces, and basic punctuation (._-)', 'error');
                    return;
                }
                
                // Check password if enforced in settings
                if (appSettings.enforcePwdProtection && !keyPassword) {
                    showStatus('keyStatus', 'Password protection is required by your security settings', 'error');
                    return;
                }
                
                // Check password strength
                if (keyPassword) {
                    const strength = validator.measurePasswordStrength(keyPassword);
                    if (strength.score < 4) {
                        showStatus('keyStatus', 'Please use a stronger password: ' + strength.feedback, 'error');
                        return;
                    }
                    
                    // Confirm password match
                    if (keyPassword !== confirmKeyPassword) {
                        showStatus('keyStatus', 'Passwords do not match', 'error');
                        return;
                    }
                }
                
                // Check key expiry if enforced
                if (appSettings.enforceKeyExpiry && !keyExpiry) {
                    showStatus('keyStatus', 'Key expiration is required by your security settings', 'error');
                    return;
                }
                
                // Prepare key data structure
                const keyData = {
                    id: crypto.randomUUID(),
                    name: keyName,
                    type: keyType,
                    created: new Date().toISOString()
                };
                
                // Set expiry date if specified
                if (keyExpiry) {
                    const expiryDays = parseInt(keyExpiry);
                    const expiryDate = new Date();
                    expiryDate.setDate(expiryDate.getDate() + expiryDays);
                    keyData.expiry = expiryDate.toISOString();
                }
                
                // Identify if this is an asymmetric key
                const isAsymmetric = keyType === 'rsa' || keyType === 'rsa-4096' || 
                                    keyType === 'ecc' || keyType === 'ecc-p384';
                
                // For asymmetric keys, set flags to indicate it has both public and private parts
                if (isAsymmetric) {
                    keyData.hasPublic = true;
                    keyData.hasPrivate = true;
                    // Use the key ID as the pairing ID for newly generated key pairs
                    keyData.pairedKeyId = keyData.id;
                }
                
                // Generate the actual cryptographic key based on type
                if (keyType === 'aes') {
                    // For AES symmetric encryption
                    await generateAESKey(keyData, keyPassword);
                } else if (keyType === 'rsa') {
                    // For RSA 2048-bit encryption
                    await generateRSAKey(keyData, keyPassword, RSA_CONFIG.KEY_SIZE);
                } else if (keyType === 'rsa-4096') {
                    // For RSA 4096-bit encryption
                    await generateRSAKey(keyData, keyPassword, RSA_CONFIG.KEY_SIZE_4096);
                } else if (keyType === 'ecc') {
                    // For ECC P-256 encryption
                    await generateECCKey(keyData, keyPassword, ECC_CONFIG.CURVE);
                } else if (keyType === 'ecc-p384') {
                    // For ECC P-384 encryption
                    await generateECCKey(keyData, keyPassword, ECC_CONFIG.CURVE_P384);
                }
                
                keys.push(keyData);
                await saveKeys();
                
                // Clear form fields
                document.getElementById('keyName').value = '';
                document.getElementById('keyPassword').value = '';
                document.getElementById('confirmKeyPassword').value = '';
                document.getElementById('passwordStrength').className = 'password-strength';
                document.getElementById('passwordFeedback').textContent = '';
                
                const keyTypeDisplay = getKeyTypeDisplay(keyData);
                showStatus('keyStatus', `${keyTypeDisplay} key "${keyName}" generated successfully`, 'success');
            } catch (error) {
                console.error('Error generating key:', error);
                showStatus('keyStatus', 'Error generating key: ' + error.message, 'error');
            } finally {
                setLoading(false);
            }
        }

        function getPairedKeyIds(keyData) {
            // If this key is already paired, return the stored pair ID
            if (keyData.pairedKeyId) return keyData.pairedKeyId;
            
            // If this is a newly generated key, use its ID as the pair ID
            if (keyData.hasPrivate && keyData.hasPublic) return keyData.id;
            
            // For imported keys without explicit pairing, check for potential matches
            if ((keyData.type === 'rsa' || keyData.type === 'rsa-4096' || 
                keyData.type === 'ecc' || keyData.type === 'ecc-p384') && 
                (keyData.hasPublic || keyData.hasPrivate)) {
                
                const possiblePairs = keys.filter(k => 
                    k.id !== keyData.id && 
                    k.type === keyData.type && 
                    ((keyData.hasPublic && k.hasPrivate) || (keyData.hasPrivate && k.hasPublic)) &&
                    // For RSA, check modulus; for ECC, could check curve points
                    // This is a simplified check - would need more robust comparison in production
                    (k.publicKeyHash && keyData.publicKeyHash && k.publicKeyHash === keyData.publicKeyHash)
                );
                
                if (possiblePairs.length > 0) {
                    return possiblePairs[0].id;
                }
            }
            
            return null;
        }

        function zeroAllKeys() {
            // Check if there are any keys to delete
            if (keys.length === 0) {
                showStatus('keyStatus', 'No keys to delete', 'warning');
                return;
            }
            
            // Show confirmation dialog
            const confirmZero = confirm('WARNING: This will permanently delete ALL your encryption keys. This action CANNOT be undone.\n\nAre you absolutely sure you want to continue?');
            
            if (confirmZero) {
                // User confirmed, delete all keys
                const keyCount = keys.length;
                
                // Clear keys array
                keys = [];
                
                // Clear from storage
                if (appSettings.useIndexedDB && db) {
                    clearDatabase(KEYS_STORE)
                        .then(() => {
                            console.log('All keys cleared from database');
                        })
                        .catch(error => {
                            console.error('Error clearing keys from database:', error);
                        });
                } else {
                    localStorage.removeItem('LemonadeKeys');
                }
                
                // Update UI
                updateKeysList();
                updateKeySelects();
                
                // Show status message
                showStatus('keyStatus', `All keys (${keyCount}) have been permanently deleted`, 'success');
            } else {
                // User canceled
                showStatus('keyStatus', 'Key deletion canceled', 'info');
            }
        }
        
        async function generateAESKey(keyData, keyPassword) {
            // Generate a random AES key
            const key = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true, // extractable
                ['encrypt', 'decrypt']
            );
            
            // Export the key to raw format
            const rawKey = await window.crypto.subtle.exportKey('raw', key);
            
            // Convert to base64 for storage
            keyData.key = arrayBufferToBase64(rawKey);
            keyData.algorithm = AES_CONFIG.MODE;
            keyData.length = AES_CONFIG.KEY_LENGTH;
            
            // If password provided, encrypt the key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }
        
        async function generateRSAKey(keyData, keyPassword, keySize) {
            // For RSA, generate a key pair
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: RSA_CONFIG.ALGORITHM,
                    modulusLength: keySize,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]), // 65537
                    hash: RSA_CONFIG.HASH
                },
                true, // extractable
                ['encrypt', 'decrypt']
            );
            
            // Export the public key
            const publicKey = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            
            // Export the private key
            const privateKey = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            
            // Convert to base64 for storage
            keyData.publicKey = arrayBufferToBase64(publicKey);
            keyData.privateKey = arrayBufferToBase64(privateKey);
            keyData.algorithm = RSA_CONFIG.ALGORITHM;
            keyData.length = keySize;
            
            // Compute a hash of the public key for pairing purposes
            const publicKeyHash = await computeKeyHash(publicKey);
            keyData.publicKeyHash = publicKeyHash;
            
            // If password provided, encrypt the private key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }
        
        async function generateECCKey(keyData, keyPassword, curve) {
            // For ECC, generate a key pair
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                true, // extractable
                ['deriveKey', 'deriveBits']
            );
            
            // Export the public key
            const publicKey = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            
            // Export the private key
            const privateKey = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            
            // Convert to base64 for storage
            keyData.publicKey = arrayBufferToBase64(publicKey);
            keyData.privateKey = arrayBufferToBase64(privateKey);
            keyData.algorithm = 'ECDH';
            keyData.curve = curve;
            
            // Compute a hash of the public key for pairing purposes
            const publicKeyHash = await computeKeyHash(publicKey);
            keyData.publicKeyHash = publicKeyHash;
            
            // If password provided, encrypt the private key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }

        async function computeKeyHash(keyBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', keyBuffer);
            return arrayBufferToBase64(hashBuffer);
        }
        
        async function encryptKeyWithPassword(keyData, password) {
            // Generate a salt for PBKDF2
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            keyData.salt = arrayBufferToBase64(salt);
            
            // Derive a key from the password
            const derivedKey = await deriveKeyFromPassword(password, salt);
            
            // Generate an IV for encryption
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            keyData.iv = arrayBufferToBase64(iv);
            
            if (keyData.type === 'aes') {
                // Encrypt the AES key
                const encryptedKey = await encryptWithDerivedKey(
                    derivedKey,
                    base64ToArrayBuffer(keyData.key),
                    iv
                );
                
                // Replace the clear key with the encrypted one
                keyData.key = arrayBufferToBase64(encryptedKey);
                keyData.protected = true;
            } else {
                // For asymmetric keys (RSA, ECC) - encrypt the private key
                const encryptedPrivateKey = await encryptWithDerivedKey(
                    derivedKey,
                    base64ToArrayBuffer(keyData.privateKey),
                    iv
                );
                
                // Replace the clear private key with the encrypted one
                keyData.privateKey = arrayBufferToBase64(encryptedPrivateKey);
                keyData.protected = true;
            }
        }
        
        async function decryptKeyWithPassword(keyData, password) {
            try {
                // Validate inputs
                if (!keyData || !password) {
                    throw new Error('Key data and password are required');
                }
                
                if (!keyData.salt || !keyData.iv) {
                    throw new Error('Key is missing salt or IV data');
                }
                
                // Derive the key from password and salt
                const salt = base64ToArrayBuffer(keyData.salt);
                const derivedKey = await deriveKeyFromPassword(password, salt);
                
                // Get the IV
                const iv = base64ToArrayBuffer(keyData.iv);
                
                // Create a new object to avoid modifying the original
                const decryptedKeyData = { ...keyData };
                
                // Add safety check for the key type
                if (keyData.type === 'aes') {
                    if (!keyData.key) {
                        throw new Error('Missing encrypted key data');
                    }
                    
                    // Decrypt the AES key
                    const decryptedKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.key),
                        iv
                    );
                    
                    // Store the decrypted key
                    decryptedKeyData.key = arrayBufferToBase64(decryptedKey);
                    
                    // Import the key to CryptoKey object for actual use
                    decryptedKeyData._cryptoKey = await importAESKey(decryptedKey);
                } else if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                    if (!keyData.privateKey) {
                        throw new Error('Missing encrypted private key data');
                    }
                    
                    // Decrypt the RSA private key
                    const decryptedPrivateKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.privateKey),
                        iv
                    );
                    
                    // Store the decrypted private key
                    decryptedKeyData.privateKey = arrayBufferToBase64(decryptedPrivateKey);
                    
                    // Import the keys to CryptoKey objects
                    decryptedKeyData._privateKey = await importRSAPrivateKey(
                        decryptedPrivateKey,
                        keyData.length || RSA_CONFIG.KEY_SIZE
                    );
                    
                    if (keyData.publicKey) {
                        decryptedKeyData._publicKey = await importRSAPublicKey(
                            base64ToArrayBuffer(keyData.publicKey),
                            keyData.length || RSA_CONFIG.KEY_SIZE
                        );
                    }
                } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                    if (!keyData.privateKey) {
                        throw new Error('Missing encrypted private key data');
                    }
                    
                    // Decrypt the ECC private key
                    const decryptedPrivateKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.privateKey),
                        iv
                    );
                    
                    // Store the decrypted private key
                    decryptedKeyData.privateKey = arrayBufferToBase64(decryptedPrivateKey);
                    
                    // Import the keys to CryptoKey objects
                    decryptedKeyData._privateKey = await importECCPrivateKey(
                        decryptedPrivateKey,
                        keyData.curve || ECC_CONFIG.CURVE
                    );
                    
                    if (keyData.publicKey) {
                        decryptedKeyData._publicKey = await importECCPublicKey(
                            base64ToArrayBuffer(keyData.publicKey),
                            keyData.curve || ECC_CONFIG.CURVE
                        );
                    }
                } else {
                    throw new Error('Unsupported key type: ' + keyData.type);
                }
                
                // Store the decrypted key data securely in memory
                return safeMemory.store(decryptedKeyData);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Incorrect password or corrupted private key');
            }
        }
        
        function updateKeysList() {
            keysList.innerHTML = '';
            
            if (keys.length === 0) {
                keysList.innerHTML = '<p>No keys available. Generate or import a key to get started.</p>';
                return;
            }
            
            keys.forEach(keyData => {
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                
                const keyTypeDisplay = getKeyTypeDisplay(keyData);
                const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                
                // Determine key pair status badge
                let keyPairBadge = '';
                if (keyData.type === 'aes') {
                    keyPairBadge = ''; // Don't show for symmetric keys
                } else if (keyData.hasPrivate && keyData.hasPublic) {
                    keyPairBadge = '<span class="key-pair-badge full">FULL KEY PAIR</span>';
                } else if (keyData.hasPrivate) {
                    keyPairBadge = '<span class="key-pair-badge private">PRIVATE KEY</span>';
                } else if (keyData.hasPublic) {
                    keyPairBadge = '<span class="key-pair-badge public">PUBLIC KEY</span>';
                }
                
                let securityBadge = '';
                
                // Determine security level
                let securityLevel = 'low'; // Default to low (any key without password protection)

                // For keys with password protection
                if (keyData.protected) {
                    if (keyData.type === 'aes' || 
                        (keyData.type === 'rsa-4096') || 
                        (keyData.type === 'ecc-p384')) {
                        securityLevel = 'high';  // AES-256, RSA-4096, or ECC-P384 with password protection
                    } else if ((keyData.type === 'rsa') || 
                            (keyData.type === 'ecc')) {
                        securityLevel = 'medium'; // RSA-2048 or ECC-P256 with password protection
                    }
                }
                
                securityBadge = `<span class="security-badge ${securityLevel}">${securityLevel.toUpperCase()}</span>`;
                
                // Calculate expiry date and display if present
                let expiryInfo = '';
                if (keyData.expiry) {
                    const expiryDate = new Date(keyData.expiry);
                    const daysToExpiry = Math.ceil((expiryDate - new Date()) / (1000 * 60 * 60 * 24));
                    expiryInfo = `<div class="key-expiry">Expires in ${daysToExpiry} days (${expiryDate.toLocaleDateString()})</div>`;
                }
                
                // Determine which buttons to show based on key type
                let keyActions = '';
                
                // Only show "Export Public" for asymmetric keys with public parts
                if (keyData.type === 'aes') {
                    keyActions += `<button class="btn-secondary" onclick="exportKey('${keyData.id}')">Export</button>`;
                } else if (keyData.hasPublic) {
                    keyActions += `<button class="btn-secondary" onclick="exportKey('${keyData.id}')">Export Public</button>`;
                }
                
                // Add private key export button for asymmetric keys that have private parts
                if (keyData.type !== 'aes' && keyData.hasPrivate) {
                    keyActions += `<button class="btn-secondary private-key-btn" onclick="exportPrivateKey('${keyData.id}')">Private Key</button>`;
                }
                
                keyActions += `<button class="btn-secondary" onclick="deleteKey('${keyData.id}')">Delete</button>`;
                
                keyItem.innerHTML = `
                    <div class="key-header">
                        <h3>${validator.sanitizeHTML(keyData.name)} (${keyTypeDisplay}${protectedBadge}) ${securityBadge}</h3>
                        ${keyPairBadge}
                    </div>
                    <div class="key-meta">Created: ${new Date(keyData.created).toLocaleString()}</div>
                    <div class="key-meta">Algorithm: ${keyData.algorithm || ''} ${keyData.length ? keyData.length + ' bits' : keyData.curve || ''}</div>
                    ${expiryInfo}
                    <div class="key-actions">
                        ${keyActions}
                    </div>
                `;
                
                keysList.appendChild(keyItem);
            });
        }
        
        function getKeyTypeDisplay(keyData) {
            if (keyData.type === 'aes') {
                return 'AES';
            } else if (keyData.type === 'rsa') {
                return 'RSA-2048';
            } else if (keyData.type === 'rsa-4096') {
                return 'RSA-4096';
            } else if (keyData.type === 'ecc') {
                return 'ECC-P256';
            } else if (keyData.type === 'ecc-p384') {
                return 'ECC-P384';
            }
            return keyData.type.toUpperCase();
        }
        
        function updateKeySelects() {
            // Clear existing options
            encryptionKeySelect.innerHTML = '<option value="">Select a key...</option>';
            decryptionKeySelect.innerHTML = '<option value="">Select a key...</option>';
            
            // Add options for encryption (symmetric and public keys only)
            keys.forEach(keyData => {
                // For encryption, include symmetric keys and asymmetric public keys
                if (keyData.type === 'aes' || keyData.hasPublic) {
                    const option = document.createElement('option');
                    option.value = keyData.id;
                    
                    const keyTypeDisplay = getKeyTypeDisplay(keyData);
                    const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                    
                    let keyTypeBadge = '';
                    if (keyData.type !== 'aes') {
                        keyTypeBadge = keyData.hasPrivate && keyData.hasPublic ? ' [Full Pair]' : ' [Public]';
                    }
                    
                    option.text = `${keyData.name} (${keyTypeDisplay}${keyTypeBadge}${protectedBadge})`;
                    
                    encryptionKeySelect.appendChild(option);
                }
            });
            
            // Add options for decryption (symmetric and private keys only)
            keys.forEach(keyData => {
                // For decryption, include symmetric keys and asymmetric private keys
                if (keyData.type === 'aes' || keyData.hasPrivate) {
                    const option = document.createElement('option');
                    option.value = keyData.id;
                    
                    const keyTypeDisplay = getKeyTypeDisplay(keyData);
                    const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                    
                    let keyTypeBadge = '';
                    if (keyData.type !== 'aes') {
                        keyTypeBadge = keyData.hasPrivate && keyData.hasPublic ? ' [Full Pair]' : ' [Private]';
                    }
                    
                    option.text = `${keyData.name} (${keyTypeDisplay}${keyTypeBadge}${protectedBadge})`;
                    
                    decryptionKeySelect.appendChild(option);
                }
            });
        }
        
        function handleEncryptionKeyChange() {
            const keyId = encryptionKeySelect.value;
            if (!keyId) {
                document.getElementById('encryptionPasswordGroup').style.display = 'none';
                return;
            }
            
            // Find the selected key
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) return;
            
            // Show password field if key is protected
            document.getElementById('encryptionPasswordGroup').style.display = keyData.protected ? 'block' : 'none';
        }
        
        function handleDecryptionKeyChange() {
            const keyId = decryptionKeySelect.value;
            if (!keyId) {
                document.getElementById('decryptionPasswordGroup').style.display = 'none';
                return;
            }
            
            // Find the selected key
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) return;
            
            // Show password field if key is protected
            document.getElementById('decryptionPasswordGroup').style.display = keyData.protected ? 'block' : 'none';
        }
        
        // Encryption/Decryption Functions
        async function encryptMessage() {
            try {
                let messageBuffer;
                let outputFileName = '';
                
                if (encryptFileData) {
                    // File encryption
                    messageBuffer = encryptFileData;
                    // Generate random filename with .lmn extension
                    outputFileName = generateRandomFileName(6) + '.lmn';
                } else {
                    // Text encryption
                    const message = document.getElementById('encryptMessage').value;
                    if (!message) {
                        showStatus('encryptStatus', 'Please enter a message or add a file to encrypt', 'error');
                        return;
                    }
                    messageBuffer = new TextEncoder().encode(message);
                }
                
                const keyId = document.getElementById('encryptionKey').value;
                const keyPassword = document.getElementById('encryptionPassword').value;
                
                if (!keyId) {
                    showStatus('encryptStatus', 'Please select an encryption key', 'error');
                    return;
                }
                
                setLoading(true);
                
                // Find the selected key
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    showStatus('encryptStatus', 'Key not found', 'error');
                    return;
                }
                
                // Check if key is password-protected
                let decryptedKeyRef = null;
                let actualKeyData = keyData;
                
                if (keyData.protected) {
                    if (!keyPassword) {
                        showStatus('encryptStatus', 'Password required for this key', 'error');
                        return;
                    }
                    
                    decryptedKeyRef = await decryptKeyWithPassword(keyData, keyPassword);
                    actualKeyData = safeMemory.retrieve(decryptedKeyRef);
                }
                
                // Encrypt based on key type
                let encryptionResult;
                
                if (keyData.type === 'aes') {
                    encryptionResult = await encryptWithAES(messageBuffer, actualKeyData);
                } else if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                    encryptionResult = await encryptWithRSA(messageBuffer, actualKeyData);
                } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                    encryptionResult = await encryptWithECC(messageBuffer, actualKeyData);
                } else {
                    throw new Error('Unsupported key type');
                }
                
                // Clean up sensitive data if we decrypted a protected key
                if (decryptedKeyRef) {
                    safeMemory.delete(decryptedKeyRef);
                }
                
                // Add file information if encrypting a file
                if (encryptFileData) {
                    encryptionResult.fileName = encryptFileName;
                    encryptionResult.fileSize = encryptFileData.byteLength;
                    encryptionResult.isFile = true;
                }
                
                // Encode the encryption info as a JSON string and then as base64
                const encryptionInfoStr = JSON.stringify(encryptionResult);
                const encodedEncryptionInfo = btoa(encryptionInfoStr);
                
                // Add a header to indicate this is a Lemonade encrypted message
                const encryptedOutput = `--LM--\n${encodedEncryptionInfo}\n--EM--`;
                
                document.getElementById('encryptedOutput').value = encryptedOutput;
                
                // Store the output file name for download
                document.getElementById('downloadEncryptedBtn').setAttribute('data-filename', outputFileName);
                
                showStatus('encryptStatus', 'Message encrypted successfully', 'success');
            } catch (error) {
                console.error('Encryption error:', error);
                showStatus('encryptStatus', 'Encryption error: ' + error.message, 'error');
            } finally {
                // Clear password field for security
                document.getElementById('encryptionPassword').value = '';
                setLoading(false);
            }
        }
        
        async function encryptWithAES(messageBuffer, keyData) {
            // Generate a random IV
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // Import the key for use with SubtleCrypto
            let cryptoKey;
            if (keyData._cryptoKey) {
                cryptoKey = keyData._cryptoKey;
            } else {
                const keyBuffer = base64ToArrayBuffer(keyData.key);
                cryptoKey = await importAESKey(keyBuffer);
            }
            
            // Encrypt with AES-GCM
            const encryptedData = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                cryptoKey,
                messageBuffer
            );
            
            // Create encryption info object
            return {
                algorithm: AES_CONFIG.MODE,
                keyId: keyData.id,
                iv: arrayBufferToBase64(iv),
                data: arrayBufferToBase64(encryptedData),
                timestamp: new Date().toISOString()
            };
        }
        
        async function encryptWithRSA(messageBuffer, keyData) {
            // For RSA, use a hybrid approach:
            // 1. Generate a random AES key
            // 2. Encrypt the message with the AES key
            // 3. Encrypt the AES key with the RSA public key
            
            // Generate a random IV
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // Generate a random AES key
            const aesKey = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true,
                ['encrypt', 'decrypt']
            );
            
            // Encrypt the message with AES
            const encryptedMessage = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                aesKey,
                messageBuffer
            );
            
            // Export the AES key
            const exportedAesKey = await window.crypto.subtle.exportKey('raw', aesKey);
            
            // Import the RSA public key
            let rsaPublicKey;
            if (keyData._publicKey) {
                rsaPublicKey = keyData._publicKey;
            } else {
                const publicKeyBuffer = base64ToArrayBuffer(keyData.publicKey);
                rsaPublicKey = await importRSAPublicKey(publicKeyBuffer, keyData.length || RSA_CONFIG.KEY_SIZE);
            }
            
            // Encrypt the AES key with RSA
            const encryptedAesKey = await window.crypto.subtle.encrypt(
                {
                    name: RSA_CONFIG.ALGORITHM
                },
                rsaPublicKey,
                exportedAesKey
            );
            
            // Create encryption info object
            return {
                algorithm: RSA_CONFIG.ALGORITHM + '+' + AES_CONFIG.MODE,
                keyId: keyData.id,
                iv: arrayBufferToBase64(iv),
                encryptedKey: arrayBufferToBase64(encryptedAesKey),
                data: arrayBufferToBase64(encryptedMessage),
                timestamp: new Date().toISOString(),
                keySize: keyData.length || RSA_CONFIG.KEY_SIZE
            };
        }
        
        async function encryptWithECC(messageBuffer, keyData) {
            // For ECC, use a hybrid approach:
            // 1. Generate ephemeral ECC key pair
            // 2. Perform ECDH key derivation
            // 3. Use derived key for AES encryption
            
            // Generate a random IV
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // Generate an ephemeral ECC key pair
            const ephemeralKeyPair = await window.crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: keyData.curve || ECC_CONFIG.CURVE
                },
                true,
                ['deriveKey', 'deriveBits']
            );
            
            // Export the ephemeral public key to send with the message
            const ephemeralPublicKey = await window.crypto.subtle.exportKey(
                'spki',
                ephemeralKeyPair.publicKey
            );
            
            // Import the recipient's public key
            let recipientPublicKey;
            if (keyData._publicKey) {
                recipientPublicKey = keyData._publicKey;
            } else {
                const publicKeyBuffer = base64ToArrayBuffer(keyData.publicKey);
                recipientPublicKey = await importECCPublicKey(
                    publicKeyBuffer,
                    keyData.curve || ECC_CONFIG.CURVE
                );
            }
            
            // Derive a shared secret using ECDH
            const derivedKey = await window.crypto.subtle.deriveKey(
                {
                    name: 'ECDH',
                    public: recipientPublicKey
                },
                ephemeralKeyPair.privateKey,
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                false,
                ['encrypt']
            );
            
            // Encrypt the message with the derived key
            const encryptedMessage = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                derivedKey,
                messageBuffer
            );
            
            // Create encryption info object
            return {
                algorithm: 'ECDH+' + AES_CONFIG.MODE,
                keyId: keyData.id,
                iv: arrayBufferToBase64(iv),
                ephemeralPublicKey: arrayBufferToBase64(ephemeralPublicKey),
                data: arrayBufferToBase64(encryptedMessage),
                timestamp: new Date().toISOString(),
                curve: keyData.curve || ECC_CONFIG.CURVE
            };
        }
        
        async function decryptMessage() {
            try {
                let encryptedData;
                let encryptionInfo;
                
                if (decryptFileData && !document.getElementById('encryptedMessage').value.includes('--LM--')) {
                    // Binary file decryption - not yet supported
                    showStatus('decryptStatus', 'Raw binary file decryption is not supported. File must be in Lemonade encrypted format.', 'error');
                    return;
                } else {
                    // Text decryption
                    const encryptedMessage = document.getElementById('encryptedMessage').value;
                    
                    if (!encryptedMessage) {
                        showStatus('decryptStatus', 'Please enter an encrypted message or add an encrypted file', 'error');
                        return;
                    }
                    
                    // Validate the encrypted message format
                    if (!validator.isValidEncryptedMessage(encryptedMessage)) {
                        showStatus('decryptStatus', 'Invalid encrypted message format', 'error');
                        return;
                    }
                    
                    // Parse the encrypted message
                    const messageMatch = encryptedMessage.match(/--LM--([\s\S]+?)--EM--/);
                    if (!messageMatch || !messageMatch[1]) {
                        showStatus('decryptStatus', 'Invalid encrypted message format', 'error');
                        return;
                    }
                    
                    const encodedEncryptionInfo = messageMatch[1].trim();
                    
                    try {
                        encryptionInfo = JSON.parse(atob(encodedEncryptionInfo));
                    } catch (error) {
                        showStatus('decryptStatus', 'Invalid encrypted message data', 'error');
                        return;
                    }
                }
                
                const keyId = document.getElementById('decryptionKey').value;
                const keyPassword = document.getElementById('decryptionPassword').value;
                
                if (!keyId) {
                    showStatus('decryptStatus', 'Please select a decryption key', 'error');
                    return;
                }
                
                setLoading(true);
                
                // Check if the message was encrypted with the selected key
                if (encryptionInfo.keyId !== keyId) {
                    showStatus('decryptStatus', 'This message was not encrypted with the selected key', 'error');
                    return;
                }
                
                // Find the selected key
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    showStatus('decryptStatus', 'Key not found', 'error');
                    return;
                }
                
                // Check if key is password-protected
                let decryptedKeyRef = null;
                let actualKeyData = keyData;
                
                if (keyData.protected) {
                    if (!keyPassword) {
                        showStatus('decryptStatus', 'Password required for this key', 'error');
                        return;
                    }
                    
                    decryptedKeyRef = await decryptKeyWithPassword(keyData, keyPassword);
                    actualKeyData = safeMemory.retrieve(decryptedKeyRef);
                }
                
                // Decrypt based on algorithm
                let decryptedData;
                
                if (encryptionInfo.algorithm === AES_CONFIG.MODE) {
                    decryptedData = await decryptWithAES(encryptionInfo, actualKeyData);
                } else if (encryptionInfo.algorithm === RSA_CONFIG.ALGORITHM + '+' + AES_CONFIG.MODE) {
                    decryptedData = await decryptWithRSA(encryptionInfo, actualKeyData);
                } else if (encryptionInfo.algorithm === 'ECDH+' + AES_CONFIG.MODE) {
                    decryptedData = await decryptWithECC(encryptionInfo, actualKeyData);
                } else {
                    throw new Error('Unsupported encryption algorithm: ' + encryptionInfo.algorithm);
                }
                
                // Clean up sensitive data if we decrypted a protected key
                if (decryptedKeyRef) {
                    safeMemory.delete(decryptedKeyRef);
                }
                
                // Check if it's a file or text
                if (encryptionInfo.isFile && encryptionInfo.fileName) {
                    // It's a file - store the decrypted data and file name
                    document.getElementById('decryptedOutput').value = `File: ${encryptionInfo.fileName} (${formatFileSize(encryptionInfo.fileSize || decryptedData.byteLength)})`;
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-filename', encryptionInfo.fileName);
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-binary', 'true');
                    // Store the binary data for download
                    window.decryptedBinaryData = decryptedData;
                } else {
                    // It's text
                    const decryptedText = new TextDecoder().decode(decryptedData);
                    document.getElementById('decryptedOutput').value = decryptedText;
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-filename', 'decrypted.txt');
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-binary', 'false');
                    window.decryptedBinaryData = null;
                }
                
                showStatus('decryptStatus', 'Message decrypted successfully', 'success');
            } catch (error) {
                console.error('Decryption error:', error);
                showStatus('decryptStatus', 'Decryption error: ' + error.message, 'error');
            } finally {
                // Clear password field for security
                document.getElementById('decryptionPassword').value = '';
                setLoading(false);
            }
        }
        
        async function decryptWithAES(encryptionInfo, keyData) {
            // Get the encrypted data and IV
            const encryptedData = base64ToArrayBuffer(encryptionInfo.data);
            const iv = base64ToArrayBuffer(encryptionInfo.iv);
            
            // Import the key for use with SubtleCrypto
            let cryptoKey;
            if (keyData._cryptoKey) {
                cryptoKey = keyData._cryptoKey;
            } else {
                const keyBuffer = base64ToArrayBuffer(keyData.key);
                cryptoKey = await importAESKey(keyBuffer);
            }
            
            // Decrypt with AES-GCM
            const decryptedData = await window.crypto.subtle.decrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                cryptoKey,
                encryptedData
            );
            
            // Return raw buffer instead of text
            return decryptedData;
        }
        
        async function decryptWithRSA(encryptionInfo, keyData) {
            // Get the encrypted AES key, encrypted data, and IV
            const encryptedAesKey = base64ToArrayBuffer(encryptionInfo.encryptedKey);
            const encryptedData = base64ToArrayBuffer(encryptionInfo.data);
            const iv = base64ToArrayBuffer(encryptionInfo.iv);
            
            // Import the RSA private key
            let rsaPrivateKey;
            if (keyData._privateKey) {
                rsaPrivateKey = keyData._privateKey;
            } else {
                const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                rsaPrivateKey = await importRSAPrivateKey(
                    privateKeyBuffer,
                    encryptionInfo.keySize || keyData.length || RSA_CONFIG.KEY_SIZE
                );
            }
            
            // Decrypt the AES key with RSA
            const aesKeyBuffer = await window.crypto.subtle.decrypt(
                {
                    name: RSA_CONFIG.ALGORITHM
                },
                rsaPrivateKey,
                encryptedAesKey
            );
            
            // Import the AES key
            const aesKey = await importAESKey(aesKeyBuffer);
            
            // Decrypt the message with the AES key
            const decryptedData = await window.crypto.subtle.decrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                aesKey,
                encryptedData
            );
            
            // Return raw buffer instead of text
            return decryptedData;
        }

        async function decryptWithECC(encryptionInfo, keyData) {
            // Get the encrypted data, ephemeral public key, and IV
            const encryptedData = base64ToArrayBuffer(encryptionInfo.data);
            const ephemeralPublicKeyBuffer = base64ToArrayBuffer(encryptionInfo.ephemeralPublicKey);
            const iv = base64ToArrayBuffer(encryptionInfo.iv);
            
            // Import the ephemeral public key
            const ephemeralPublicKey = await importECCPublicKey(
                ephemeralPublicKeyBuffer,
                encryptionInfo.curve || ECC_CONFIG.CURVE
            );
            
            // Import the private key
            let privateKey;
            if (keyData._privateKey) {
                privateKey = keyData._privateKey;
            } else {
                const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                privateKey = await importECCPrivateKey(
                    privateKeyBuffer,
                    encryptionInfo.curve || ECC_CONFIG.CURVE
                );
            }
            
            // Derive the shared secret using ECDH
            const derivedKey = await window.crypto.subtle.deriveKey(
                {
                    name: 'ECDH',
                    public: ephemeralPublicKey
                },
                privateKey,
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                false,
                ['decrypt']
            );
            
            // Decrypt the message with the derived key
            const decryptedData = await window.crypto.subtle.decrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                derivedKey,
                encryptedData
            );
            
            // Return raw buffer instead of text
            return decryptedData;
        }

        // File download functions
        function downloadEncryptedFile() {
            const encryptedOutput = document.getElementById('encryptedOutput').value;
            if (!encryptedOutput) {
                showStatus('encryptStatus', 'No encrypted data to download', 'error');
                return;
            }
            
            const filename = document.getElementById('downloadEncryptedBtn').getAttribute('data-filename') || generateRandomFileName(6) + '.lmn';
            
            const blob = new Blob([encryptedOutput], { type: 'application/octet-stream' });
            downloadBlob(blob, filename);
            
            showStatus('encryptStatus', `File "${filename}" downloaded successfully`, 'success');
        }

        function downloadDecryptedFile() {
            if (window.decryptedBinaryData) {
                // Binary file
                const filename = document.getElementById('downloadDecryptedBtn').getAttribute('data-filename') || 'decrypted_file';
                const blob = new Blob([window.decryptedBinaryData], { type: 'application/octet-stream' });
                downloadBlob(blob, filename);
            } else {
                // Text file
                const decryptedOutput = document.getElementById('decryptedOutput').value;
                if (!decryptedOutput) {
                    showStatus('decryptStatus', 'No decrypted data to download', 'error');
                    return;
                }
                
                const filename = document.getElementById('downloadDecryptedBtn').getAttribute('data-filename') || 'decrypted.txt';
                // Also change MIME type here for consistency
                const blob = new Blob([decryptedOutput], { type: 'application/octet-stream' });
                downloadBlob(blob, filename);
            }
            
            showStatus('decryptStatus', 'File downloaded successfully', 'success');
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Key Import/Export Functions
        function importKey() {
            const keyFileInput = createKeyFileInput();
            keyFileInput.click();
        }
        
        async function exportKey(keyId, exportPrivate = false) {
            try {
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    alert('Key not found');
                    return;
                }
                
                // Check if trying to export a private key
                const isAsymmetric = keyData.type === 'rsa' || keyData.type === 'rsa-4096' || 
                                    keyData.type === 'ecc' || keyData.type === 'ecc-p384';
                
                let exportData = keyData;
                let fileExtension = '.lim'; // Default for public or symmetric keys
                
                if (isAsymmetric && exportPrivate) {
                    // If exporting private key part, prompt for password
                    const exportPassword = prompt("Please enter a password to protect this private key:", "");
                    if (!exportPassword) {
                        // User cancelled or entered empty password
                        if (!confirm("Warning: Exporting a private key without password protection is a security risk. Continue anyway?")) {
                            return;
                        }
                    }
                    
                    // Prepare private key export - clone the key data
                    exportData = {
                        id: keyData.id,
                        name: keyData.name,
                        type: keyData.type,
                        created: keyData.created,
                        expiry: keyData.expiry,
                        privateKey: keyData.privateKey,
                        protected: keyData.protected,
                        salt: keyData.salt,
                        iv: keyData.iv,
                        algorithm: keyData.algorithm,
                        hasPrivate: true,
                        hasPublic: false,
                        pairedKeyId: keyData.id,
                        publicKeyHash: keyData.publicKeyHash
                    };
                    
                    // Add length or curve specific to RSA or ECC
                    if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                        exportData.length = keyData.length;
                    } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                        exportData.curve = keyData.curve;
                    }
                    
                    // If a new password was provided, encrypt the private key with it
                    if (exportPassword) {
                        // Decrypt with original password if needed
                        if (keyData.protected) {
                            // This assumes the key is already unlocked in memory
                            // In a real implementation, you'd need to prompt for the original password
                            const decryptedKeyRef = await decryptKeyWithPassword(keyData, prompt("Enter the current key password:", ""));
                            const decryptedKey = safeMemory.retrieve(decryptedKeyRef, true);
                            exportData.privateKey = decryptedKey.privateKey;
                            exportData.protected = false; // Reset protection status
                        }
                        
                        // Encrypt with new password
                        await encryptKeyWithPassword(exportData, exportPassword);
                    }
                    
                    fileExtension = '.lem'; // Private key extension
                } else if (isAsymmetric && !exportPrivate) {
                    // Exporting public key - remove private key data
                    exportData = {
                        id: keyData.id,
                        name: keyData.name,
                        type: keyData.type,
                        created: keyData.created,
                        expiry: keyData.expiry,
                        publicKey: keyData.publicKey,
                        algorithm: keyData.algorithm,
                        hasPublic: true,
                        hasPrivate: false,
                        pairedKeyId: keyData.id,
                        publicKeyHash: keyData.publicKeyHash
                    };
                    
                    // Add length or curve specific to RSA or ECC
                    if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                        exportData.length = keyData.length;
                    } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                        exportData.curve = keyData.curve;
                    }
                }
                
                // Convert key data to JSON and then to base64
                const jsonText = JSON.stringify(exportData);
                const exportText = btoa(jsonText);
                
                // Create a download with the appropriate extension
                const blob = new Blob([exportText], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${keyData.name.replace(/[^a-z0-9]/gi, '_')}${fileExtension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                const keyTypeText = exportPrivate ? "private key" : (isAsymmetric ? "public key" : "key");
                showStatus('keyStatus', `Key "${keyData.name}" ${keyTypeText} exported as ${fileExtension} file`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showStatus('keyStatus', 'Export error: ' + error.message, 'error');
            }
        }

        // Export private key function
        async function exportPrivateKey(keyId) {
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) {
                alert('Key not found');
                return;
            }
            
            // Check if this key has a private part
            if (!keyData.hasPrivate) {
                showStatus('keyStatus', 'This key does not have a private key component to export', 'error');
                return;
            }
            
            const confirmExport = confirm(
                "WARNING: Exporting a private key is a security risk. " +
                "Only export private keys if you absolutely need to use them on another device. " +
                "Do you want to continue?"
            );
            
            if (confirmExport) {
                await exportKey(keyId, true);
            }
        }

        function createKeyFileInput() {
            // Check if it already exists
            let keyFileInput = document.getElementById('keyFileInput');
            
            if (!keyFileInput) {
                keyFileInput = document.createElement('input');
                keyFileInput.type = 'file';
                keyFileInput.id = 'keyFileInput';
                keyFileInput.accept = '.lim,.lem';
                keyFileInput.style.display = 'none';
                document.body.appendChild(keyFileInput);
                
                // Add event listener
                keyFileInput.addEventListener('change', handleKeyFileSelect);
            }
            
            return keyFileInput;
        }

        async function handleKeyFileSelect(event) {
            try {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                setLoading(true);
                const file = files[0];
                
                // Check file extension
                const isPrivateKey = file.name.toLowerCase().endsWith('.lem');
                const isPublicKey = file.name.toLowerCase().endsWith('.lim');
                
                // Read the file content
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const importText = e.target.result;
                        let keyData;
                        
                        try {
                            const jsonText = atob(importText);
                            keyData = JSON.parse(jsonText);
                        } catch (error) {
                            throw new Error('Invalid key file format');
                        }
                        
                        // Validate the key data
                        if (!keyData.id || !keyData.name || !keyData.type || !keyData.created) {
                            throw new Error('Missing required key properties');
                        }
                        
                        // Validate key name
                        if (!validator.isValidKeyName(keyData.name)) {
                            throw new Error('Invalid key name format');
                        }
                        
                        // Set hasPublic/hasPrivate flags if not already present (for backwards compatibility)
                        if (keyData.type === 'aes') {
                            // Symmetric keys always have both
                            keyData.hasPublic = true;
                            keyData.hasPrivate = true;
                        } else {
                            // For asymmetric keys, check what's in the file
                            keyData.hasPublic = !!keyData.publicKey;
                            keyData.hasPrivate = !!keyData.privateKey;
                            
                            // If extension is .lem but file doesn't have privateKey, warn
                            if (isPrivateKey && !keyData.hasPrivate) {
                                throw new Error('This .lem file does not contain a private key');
                            }
                            
                            // If extension is .lim but file doesn't have publicKey, warn
                            if (isPublicKey && !keyData.hasPublic) {
                                throw new Error('This .lim file does not contain a public key');
                            }
                        }
                        
                        // If importing a private key that's password-protected, prompt for password
                        if (keyData.hasPrivate && keyData.protected) {
                        const importPassword = prompt("This private key is password-protected. Please enter the password to import it:", "");
                        if (!importPassword) {
                            throw new Error('Password is required to import this protected private key');
                        }
                        
                        // Store the original password for later use
                        keyData._importPassword = importPassword;
                        }
                        
                        // Check if a key with this ID already exists
                        const existingKeyIndex = keys.findIndex(k => k.id === keyData.id);
                        
                        // Check if this might be a private key for an existing public key or vice versa
                        let isPotentialPair = false;
                        let pairIndex = -1;
                        
                        if (existingKeyIndex >= 0) {
                            const existingKey = keys[existingKeyIndex];
                            
                            // If importing private key and existing key is public-only
                            if (keyData.hasPrivate && !existingKey.hasPrivate && existingKey.hasPublic) {
                                isPotentialPair = true;
                                pairIndex = existingKeyIndex;
                            }
                            // If importing public key and existing key is private-only
                            else if (keyData.hasPublic && !existingKey.hasPublic && existingKey.hasPrivate) {
                                isPotentialPair = true;
                                pairIndex = existingKeyIndex;
                            }
                        } else {
                            // Check if there's a potential pair by public key hash
                            if (keyData.publicKeyHash) {
                                pairIndex = keys.findIndex(k => 
                                    k.publicKeyHash === keyData.publicKeyHash && 
                                    k.type === keyData.type &&
                                    ((k.hasPrivate && !k.hasPublic && keyData.hasPublic) || 
                                    (k.hasPublic && !k.hasPrivate && keyData.hasPrivate))
                                );
                                
                                if (pairIndex >= 0) {
                                    isPotentialPair = true;
                                }
                            }
                        }
                        
                        if (isPotentialPair && pairIndex >= 0) {
                            // We found a potential pair - ask if user wants to merge them
                            const mergePair = confirm(
                                `This appears to be the ${keyData.hasPrivate ? 'private' : 'public'} key part of an existing key. ` +
                                `Would you like to merge them into a complete key pair?`
                            );
                            
                            if (mergePair) {
                                // Merge the keys
                                const existingKey = keys[pairIndex];
                                
                                // If importing private key, add it to the existing key
                                if (keyData.hasPrivate && !existingKey.hasPrivate) {
                                    existingKey.privateKey = keyData.privateKey;
                                    existingKey.hasPrivate = true;
                                    
                                    // Copy protection settings if the private key is protected
                                    if (keyData.protected) {
                                        existingKey.protected = true;
                                        existingKey.salt = keyData.salt;
                                        existingKey.iv = keyData.iv;
                                    }
                                }
                                
                                // If importing public key, add it to the existing key
                                if (keyData.hasPublic && !existingKey.hasPublic) {
                                    existingKey.publicKey = keyData.publicKey;
                                    existingKey.hasPublic = true;
                                    
                                    // Update public key hash if needed
                                    if (keyData.publicKeyHash) {
                                        existingKey.publicKeyHash = keyData.publicKeyHash;
                                    }
                                }
                                
                                // Set paired ID for both to be the same
                                existingKey.pairedKeyId = existingKey.id;
                                
                                await saveKeys();
                                showStatus('keyStatus', `Key "${existingKey.name}" updated with ${keyData.hasPrivate ? 'private' : 'public'} key part`, 'success');
                            } else {
                                // User chose not to merge, import as separate key
                                keyData.id = crypto.randomUUID(); // Generate new ID to avoid conflict
                                keys.push(keyData);
                                await saveKeys();
                                showStatus('keyStatus', `Key "${keyData.name}" imported as separate key`, 'success');
                            }
                        } else if (existingKeyIndex >= 0) {
                            // A key with this ID exists but isn't a potential pair
                            const overwrite = confirm(`A key with name "${keyData.name}" already exists. Overwrite?`);
                            if (overwrite) {
                                keys[existingKeyIndex] = keyData;
                            } else {
                                // Generate a new ID for the key
                                keyData.id = crypto.randomUUID();
                                keys.push(keyData);
                            }
                            await saveKeys();
                            showStatus('keyStatus', `Key "${keyData.name}" imported successfully`, 'success');
                        } else {
                            // No existing key with this ID
                            keys.push(keyData);
                            await saveKeys();
                            
                            // Show appropriate message based on key type
                            if (keyData.type === 'aes') {
                                showStatus('keyStatus', `Symmetric key "${keyData.name}" imported successfully`, 'success');
                            } else if (keyData.hasPrivate && keyData.hasPublic) {
                                showStatus('keyStatus', `Complete asymmetric key pair "${keyData.name}" imported successfully`, 'success');
                            } else if (keyData.hasPrivate) {
                                showStatus('keyStatus', `Private key "${keyData.name}" imported successfully`, 'success');
                            } else {
                                showStatus('keyStatus', `Public key "${keyData.name}" imported successfully`, 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        showStatus('keyStatus', 'Import error: ' + error.message, 'error');
                    } finally {
                        setLoading(false);
                        // Reset the input so the same file can be selected again
                        document.getElementById('keyFileInput').value = '';
                    }
                };
                
                reader.onerror = function() {
                    setLoading(false);
                    showStatus('keyStatus', 'Error reading the key file', 'error');
                    document.getElementById('keyFileInput').value = '';
                };
                
                reader.readAsText(file);
                
            } catch (error) {
                console.error('Import error:', error);
                showStatus('keyStatus', 'Import error: ' + error.message, 'error');
                setLoading(false);
                document.getElementById('keyFileInput').value = '';
            }
        }
        
        async function exportAllKeys() {
            try {
                if (keys.length === 0) {
                    showStatus('keyStatus', 'No keys available to export', 'warning');
                    return;
                }
                
                // Ask for a password to protect the export
                const password = prompt("Please enter a password to protect your key backup. This is highly recommended for security.", "");
                
                // Create a data blob
                let exportData;
                
                if (password) {
                    // Encrypt the keys for additional security
                    const keysJson = JSON.stringify(keys);
                    const keysBuffer = new TextEncoder().encode(keysJson);
                    
                    // Generate salt and derive key
                    const salt = window.crypto.getRandomValues(new Uint8Array(16));
                    const derivedKey = await deriveKeyFromPassword(password, salt);
                    
                    // Generate IV
                    const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
                    
                    // Encrypt keys
                    const encryptedKeys = await encryptWithDerivedKey(derivedKey, keysBuffer, iv);
                    
                    // Create protected export format
                    exportData = JSON.stringify({
                        format: 'LemonadeProtectedBackup',
                        salt: arrayBufferToBase64(salt),
                        iv: arrayBufferToBase64(iv),
                        data: arrayBufferToBase64(encryptedKeys)
                    });
                } else {
                    // Unprotected export - show warning
                    const confirmUnprotected = confirm("WARNING: Exporting keys without a password is not secure. Anyone with access to this file will be able to use your keys. Continue anyway?");
                    if (!confirmUnprotected) return;
                    
                    exportData = JSON.stringify(keys);
                }
                
                // Create the download link - using application/octet-stream for better Android compatibility
                const blob = new Blob([exportData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Lemonade-state.state';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('keyStatus', 'Application state exported successfully', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showStatus('keyStatus', 'Export error: ' + error.message, 'error');
            }
        }

        function createStateFileInput() {
            // Check if it already exists
            let stateFileInput = document.getElementById('stateFileInput');
            
            if (!stateFileInput) {
                stateFileInput = document.createElement('input');
                stateFileInput.type = 'file';
                stateFileInput.id = 'stateFileInput';
                stateFileInput.accept = '.state,application/octet-stream';  // Accept both .state extension and octet-stream type
                stateFileInput.style.display = 'none';
                document.body.appendChild(stateFileInput);
                
                // Add event listener
                stateFileInput.addEventListener('change', handleStateFileSelect);
            }
            
            return stateFileInput;
        }

        async function handleStateFileSelect(event) {
            try {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                setLoading(true);
                const file = files[0];
                
                // Read the file content
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const importText = e.target.result;
                        let importData;
                        
                        try {
                            importData = JSON.parse(importText);
                        } catch (error) {
                            throw new Error('Invalid state file format');
                        }
                        
                        // Check if it's a protected backup
                        if (importData.format === 'LemonadeProtectedBackup') {
                            const password = prompt("This state file is password-protected. Please enter the password to import:", "");
                            if (!password) {
                                throw new Error('Password is required to import this protected state file');
                            }
                            
                            // Extract the salt, IV, and encrypted data
                            const salt = base64ToArrayBuffer(importData.salt);
                            const iv = base64ToArrayBuffer(importData.iv);
                            const encryptedData = base64ToArrayBuffer(importData.data);
                            
                            // Derive the key from the password
                            const derivedKey = await deriveKeyFromPassword(password, salt);
                            
                            // Decrypt the data
                            const decryptedData = await decryptWithDerivedKey(derivedKey, encryptedData, iv);
                            
                            // Parse the decrypted data
                            const decryptedText = new TextDecoder().decode(decryptedData);
                            importData = JSON.parse(decryptedText);
                        }
                        
                        // Validate the imported data
                        if (!Array.isArray(importData)) {
                            throw new Error('Invalid state data format');
                        }
                        
                        // Confirmation before overwriting existing keys
                        const confirmImport = confirm(`This will import ${importData.length} keys into your application. Continue?`);
                        if (!confirmImport) return;
                        
                        // Import the keys
                        keys = importData;
                        await saveKeys();
                        
                        showStatus('keyStatus', `Application state with ${importData.length} keys imported successfully`, 'success');
                    } catch (error) {
                        console.error('State import error:', error);
                        showStatus('keyStatus', 'State import error: ' + error.message, 'error');
                    } finally {
                        setLoading(false);
                        // Reset the input so the same file can be selected again
                        document.getElementById('stateFileInput').value = '';
                    }
                };
                
                reader.onerror = function() {
                    setLoading(false);
                    showStatus('keyStatus', 'Error reading the state file', 'error');
                    document.getElementById('stateFileInput').value = '';
                };
                
                reader.readAsText(file);
                
            } catch (error) {
                console.error('State import error:', error);
                showStatus('keyStatus', 'State import error: ' + error.message, 'error');
                setLoading(false);
                document.getElementById('stateFileInput').value = '';
            }
        }

        function importState() {
            const stateFileInput = createStateFileInput();
            stateFileInput.click();
        }
        
        async function secureClipboardCopy(text) {
            // Try the modern Clipboard API with secure context
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (clipboardError) {
                console.log('Modern clipboard API failed:', clipboardError);
                return false;
            }
        }
        
        function deleteKey(keyId) {
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) {
                alert('Key not found');
                return;
            }
            
            const confirm = window.confirm(`Are you sure you want to delete the key "${keyData.name}"? This action cannot be undone.`);
            if (confirm) {
                keys = keys.filter(k => k.id !== keyId);
                saveKeys();
                showStatus('keyStatus', `Key "${keyData.name}" deleted successfully`, 'success');
            }
        }
        
        // Utility Functions
        function showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            statusElement.textContent = validator.sanitizeHTML(message);
            statusElement.className = `status ${type}`;
            
            // Auto-hide status after 10 seconds
            setTimeout(() => {
                if (statusElement.textContent === validator.sanitizeHTML(message)) {
                    statusElement.className = 'status';
                }
            }, 10000);
        }
        
        async function copyToClipboard(sourceElementId, statusElementId) {
            const text = document.getElementById(sourceElementId).value;
            if (!text) {
                showStatus(statusElementId, 'Nothing to copy', 'error');
                return;
            }
            
            const success = await secureClipboardCopy(text);
            
            if (success) {
                showStatus(statusElementId, 'Copied to clipboard', 'success');
                
                // If configured, schedule clipboard clearing
                if (appSettings.clearClipboard) {
                    scheduleClipboardClear();
                }
            } else {
                showStatus(statusElementId, 'Unable to copy automatically. Please select the text and press Ctrl+C (or âŒ˜+C) to copy manually.', 'warning');
                
                // Select the text in the original element for easier manual copying
                const element = document.getElementById(sourceElementId);
                element.focus();
                element.select();
            }
        }

        function toggleDarkMode() {
            const darkModeEnabled = document.getElementById('darkMode').checked;
            if (darkModeEnabled) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            localStorage.setItem('LemonadeDarkMode', darkModeEnabled);
        }
        
        // Crypto Helper Functions
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        function base64ToArrayBuffer(base64) {
            try {
                // Try regular base64 decoding
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                console.error('Base64 decoding error:', error);
                throw new Error('Invalid base64 data: ' + error.message);
            }
        }
        
        async function deriveKeyFromPassword(password, salt) {
            // Convert password to an array buffer
            const passwordBuffer = new TextEncoder().encode(password);
            
            // Import the password as a key
            const baseKey = await window.crypto.subtle.importKey(
                'raw',
                passwordBuffer,
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            
            // Derive a key using PBKDF2
            return window.crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: PBKDF2_CONFIG.ITERATIONS,
                    hash: PBKDF2_CONFIG.HASH
                },
                baseKey,
                { name: AES_CONFIG.MODE, length: AES_CONFIG.KEY_LENGTH },
                true,
                ['encrypt', 'decrypt']
            );
        }
        
        async function encryptWithDerivedKey(key, data, iv) {
            return window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                key,
                data
            );
        }
        
        async function decryptWithDerivedKey(key, data, iv) {
            return window.crypto.subtle.decrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                key,
                data
            );
        }
        
        async function importAESKey(keyData) {
            return window.crypto.subtle.importKey(
                'raw',
                keyData,
                { name: AES_CONFIG.MODE },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        async function importRSAPublicKey(keyData, keySize) {
            return window.crypto.subtle.importKey(
                'spki',
                keyData,
                {
                    name: RSA_CONFIG.ALGORITHM,
                    hash: RSA_CONFIG.HASH
                },
                false,
                ['encrypt']
            );
        }
        
        async function importRSAPrivateKey(keyData, keySize) {
            return window.crypto.subtle.importKey(
                'pkcs8',
                keyData,
                {
                    name: RSA_CONFIG.ALGORITHM,
                    hash: RSA_CONFIG.HASH
                },
                false,
                ['decrypt']
            );
        }
        
        async function importECCPublicKey(keyData, curve) {
            return window.crypto.subtle.importKey(
                'spki',
                keyData,
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                false,
                []
            );
        }
        
        async function importECCPrivateKey(keyData, curve) {
            return window.crypto.subtle.importKey(
                'pkcs8',
                keyData,
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                false,
                ['deriveKey', 'deriveBits']
            );
        }
        
        // Database Helper Functions
        async function saveToDatabase(storeName, data) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        async function getFromDatabase(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function getAllFromDatabase(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function clearDatabase(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Make functions globally available for onclick handlers
        window.exportKey = exportKey;
        window.exportPrivateKey = exportPrivateKey;
        window.deleteKey = deleteKey;

        // PWA Support
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');
        const installContainer = document.getElementById('installContainer');
        const installStatus = document.getElementById('installStatus');

        // Initially disable the install button until we know it's available
        if (installBtn) {
            installBtn.disabled = true;
        }

        // Handle PWA installation
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67+ from automatically showing the prompt
            e.preventDefault();
            
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Enable the install button
            if (installBtn) {
                installBtn.disabled = false;
                const noteElement = installContainer.querySelector('.install-note');
                if (noteElement) {
                    noteElement.style.display = 'none';
                }
                showStatus('installStatus', 'Installation is now available!', 'success');
            }
        });

        // Install button click handler
        if (installBtn) {
            installBtn.addEventListener('click', async () => {
                if (!deferredPrompt) {
                    showStatus('installStatus', 'Installation not available in this browser or app is already installed', 'warning');
                    return;
                }
                
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to install prompt: ${outcome}`);
                
                if (outcome === 'accepted') {
                    showStatus('installStatus', 'Lemonade has been installed successfully!', 'success');
                } else {
                    showStatus('installStatus', 'Installation was canceled', 'warning');
                }
                
                // Clear the saved prompt since it can't be used again
                deferredPrompt = null;
                installBtn.disabled = true;
            });
        }

        // Check if already installed
        window.addEventListener('appinstalled', () => {
            console.log('Lemonade was installed');
            deferredPrompt = null;
            if (installBtn) {
                installBtn.disabled = true;
            }
            showStatus('installStatus', 'Lemonade has been installed successfully!', 'success');
        });

        // Register service worker
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || 
            window.location.hostname === 'localhost' || 
            window.location.hostname === '127.0.0.1')) {
            
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('sw.js')
                    .then(function(registration) {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(function(error) {
                        console.error('Service Worker registration failed:', error);
                        showStatus('installStatus', 'Service Worker registration failed. PWA features unavailable.', 'warning');
                    });
            });
        } else {
            console.log('Service Workers not supported or not in secure context');
            if (installStatus) {
                if (window.location.protocol === 'file:') {
                    showStatus('installStatus', 'PWA installation requires HTTPS. You are viewing this file locally.', 'warning');
                } else {
                    showStatus('installStatus', 'Your browser does not support PWA installation features.', 'warning');
                }
            }
        }

        // Check display mode
        if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('App is already running in standalone mode (installed)');
            if (installStatus) {
                showStatus('installStatus', 'Lemonade is running as an installed app', 'success');
            }
        }

        // File handling variables
        let encryptFileData = null;
        let encryptFileName = '';
        let decryptFileData = null;
        let decryptFileName = '';

        // Setup file drop areas
        document.addEventListener('DOMContentLoaded', function() {
            // Setup file input elements
            const encryptFileInput = document.getElementById('encryptFileInput');
            const encryptBrowseBtn = document.getElementById('encryptBrowseBtn');
            const encryptFileInfo = document.getElementById('encryptFileInfo');
            const encryptFileNameEl = document.getElementById('encryptFileName');
            const removeEncryptFile = document.getElementById('removeEncryptFile');
                
            // Setup decrypt file elements
            const decryptFileInput = document.getElementById('decryptFileInput');
            const decryptBrowseBtn = document.getElementById('decryptBrowseBtn');
            const decryptFileInfo = document.getElementById('decryptFileInfo');
            const decryptFileNameEl = document.getElementById('decryptFileName');
            const removeDecryptFile = document.getElementById('removeDecryptFile');
            
            // Download buttons
            const downloadEncryptedBtn = document.getElementById('downloadEncryptedBtn');
            const downloadDecryptedBtn = document.getElementById('downloadDecryptedBtn');
            
            // Encrypt file area event listeners            
            encryptBrowseBtn.addEventListener('click', () => {
                encryptFileInput.click();
            });
            
            encryptFileInput.addEventListener('change', (e) => {
                handleEncryptFileSelect(e.target.files);
            });
            
            removeEncryptFile.addEventListener('click', () => {
                clearEncryptFile();
            });
            
            // Decrypt file area event listeners            
            decryptBrowseBtn.addEventListener('click', () => {
                decryptFileInput.click();
            });
            
            decryptFileInput.addEventListener('change', (e) => {
                handleDecryptFileSelect(e.target.files);
            });
            
            removeDecryptFile.addEventListener('click', () => {
                clearDecryptFile();
            });

            // Create the key file input element on page load
            createKeyFileInput();
            
            // Download file event listeners
            downloadEncryptedBtn.addEventListener('click', downloadEncryptedFile);
            downloadDecryptedBtn.addEventListener('click', downloadDecryptedFile);

            document.getElementById('encryptBtn').addEventListener('click', function() {
            // Clear any previous decrypted binary data
            window.decryptedBinaryData = null;
        });
        });

        // File handling functions
        function handleEncryptFileSelect(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            encryptFileName = file.name;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                encryptFileData = e.target.result;
                document.getElementById('encryptMessage').value = `File: ${encryptFileName} (${formatFileSize(file.size)})`;
                document.getElementById('encryptFileInfo').style.display = 'flex';
                document.getElementById('encryptFileName').textContent = encryptFileName;
            };
            reader.readAsArrayBuffer(file);
        }

        function handleDecryptFileSelect(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            decryptFileName = file.name;
            
            // Always try to read as text first for .encrypted files
            const textReader = new FileReader();
            textReader.onload = function(textEvent) {
                const textContent = textEvent.target.result;
                
                // Check if it's a valid Lemonade encrypted format
                if (textContent.includes('--LM--') && textContent.includes('--EM--')) {
                    // It's a valid Lemonade encrypted message
                    document.getElementById('encryptedMessage').value = textContent;
                    decryptFileData = null; // Not treating as binary
                    document.getElementById('decryptFileInfo').style.display = 'flex';
                    document.getElementById('decryptFileName').textContent = decryptFileName;
                    showStatus('decryptStatus', 'Encrypted file loaded successfully.', 'success');
                } else {
                    // Not a valid Lemonade format, might be binary
                    showStatus('decryptStatus', 'This file is not in Lemonade encrypted format. Files must have the Lemonade header/footer markers.', 'error');
                    document.getElementById('decryptFileInfo').style.display = 'none';
                }
            };
            
            textReader.onerror = function() {
                // Error reading as text, likely a binary file
                showStatus('decryptStatus', 'Unable to read the file as a Lemonade encrypted format.', 'error');
            };
            
            // Read the file as text, regardless of its type
            textReader.readAsText(file);
        }

        function clearEncryptFile() {
            encryptFileData = null;
            encryptFileName = '';
            document.getElementById('encryptMessage').value = '';
            document.getElementById('encryptFileInfo').style.display = 'none';
            document.getElementById('encryptFileInput').value = '';
        }

        function clearDecryptFile() {
            decryptFileData = null;
            decryptFileName = '';
            document.getElementById('encryptedMessage').value = '';
            document.getElementById('decryptFileInfo').style.display = 'none';
            document.getElementById('decryptFileInput').value = '';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function generateRandomFileName(length = 6) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

    </script>
</body>
</html>
