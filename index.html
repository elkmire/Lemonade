<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="no-referrer">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=()">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Lemonade">
    <link rel="icon" href="icon.svg">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="manifest" href="manifest.json">
    <title>Lemonade</title>
    <style>
/* CSS with dark/light mode support */
:root {
    --bg-color: #ffffff;
    --text-color: #000000;
    --title-gradient: linear-gradient(90deg, #000000, #000000);
    --card-bg: #ffffff;
    --accent-color: #000000;
    --border-color: #dddddd;
    --input-bg: #ffffff;
    --button-bg: #000000;
    --button-text: #ffffff;
    --button-hover: #333333;
    --success-color: #00cc66;
    --error-color: #cc3300;
    --warning-color: #f0ad4e;
    --cyber-line: rgba(0, 0, 0, 0.15); /* Kept for light mode, dark mode will override */
    --cyber-glow: rgba(0, 0, 0, 0.4); /* Kept for light mode, dark mode will override */
    --security-high: #00cc66;
    --security-medium: #f0ad4e;
    --security-low: #cc3300;
    --output-bg: #f8f8f8;
    --output-text: #222222;
}

/* Dark mode class */
body.dark-mode {
    --bg-color: #000000; /* Pitch black background */
    --text-color: #E0E0E0; /* Light grey/off-white for general text */
    --title-gradient: linear-gradient(90deg, #39FF14, #FF00FF, #00FFFF); /* Green, Pink, Blue */
    --card-bg: #0A0A0A; /* Very dark grey, almost black, solid */
    --accent-color: #39FF14; /* Terminal Green */
    --border-color: #2A2A2A; /* Darker grey for subtle borders */
    --input-bg: #101010; /* Dark grey for inputs */
    --button-bg: #00FFFF; /* Cyber Blue for buttons */
    --button-text: #000000; /* Black for text on blue buttons */
    --button-hover: #FF00FF; /* Hot Pink for button hover */
    --success-color: #39FF14; /* Terminal Green for success */
    --error-color: #FF3131; /* Neon Red for error */
    --warning-color: #FFFF00; /* Neon Yellow for warning */
    --cyber-line: rgba(57, 255, 20, 0.3); /* Terminal Green, slightly transparent line */
    --cyber-glow: rgba(57, 255, 20, 0.1); /* Terminal Green, very subtle glow or none */
    --security-high: #39FF14;
    --security-medium: #FFFF00;
    --security-low: #FF3131;
    --output-bg: #050505; /* Even darker for output boxes */
    --output-text: #B2F2BB; /* Light terminal green for output text */
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    margin: 0;
    padding: 0;
    transition: background-color 0.3s, color 0.3s;
    line-height: 1.6;
    position: relative;
    overflow-x: hidden;
}

body::before {
    display: none; /* Removed psychedelic background for performance */
}

/* Solid Black Background for Dark Mode */
body.dark-mode::before {
    content: "";
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    background-color: #000000; /* Pitch black */
    opacity: 1;
}

/* Static scanlines overlay (kept as it's not resource-intensive) */
body.dark-mode::after {
    content: "";
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* Ensure it's behind content */
    background: repeating-linear-gradient(
        0deg,
        rgba(57, 255, 20, 0.05), /* Very subtle green scanlines */
        rgba(57, 255, 20, 0.05) 1px,
        transparent 1px,
        transparent 3px /* Increased spacing for subtlety */
    );
    pointer-events: none;
}

/* Enhanced App Title - No animation */
body.dark-mode .app-title {
    color: var(--accent-color); /* Use accent color for solid text */
    text-shadow: none; /* Removed text-shadow */
    background: none;
}

/* Enhanced Cards - No animation or heavy shadows */
body.dark-mode .card {
    border: 1px solid var(--accent-color); /* Terminal green border */
    box-shadow: none; /* Removed box-shadow */
    backdrop-filter: none; /* Removed backdrop-filter */
    /* animation: border-pulse 4s infinite; REMOVED */
}

/* Enhanced Buttons - No animation or heavy shadows */
body.dark-mode button {
    border: 1px solid transparent;
    box-shadow: none; /* Removed box-shadow */
    text-shadow: none; /* Removed text-shadow */
    transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease; /* Simplified transition */
    position: relative;
    overflow: hidden;
}

body.dark-mode button:hover {
    background-color: var(--button-hover); /* Uses --button-hover (Hot Pink) */
    color: var(--button-text); /* Ensure text remains readable, or set a specific hover text color */
    box-shadow: none; /* Ensure no shadow on hover */
    transform: translateY(-1px); /* Slight lift effect */
}

/* Removed Psychedelic button effects */
body.dark-mode button::before {
    display: none; /* Removed animated gradient */
}

/* Enhanced Input Fields - No animation or heavy shadows */
body.dark-mode input,
body.dark-mode textarea,
body.dark-mode select {
    border: 1px solid var(--border-color);
    box-shadow: none; /* Removed inset shadow */
    backdrop-filter: none; /* Removed backdrop-filter */
    transition: border-color 0.2s ease; /* Simplified transition */
}

body.dark-mode input:focus,
body.dark-mode textarea:focus,
body.dark-mode select:focus {
    border-color: var(--accent-color); /* Terminal green border on focus */
    box-shadow: none; /* Removed focus shadow and animation */
    /* animation: focus-pulse 2s infinite; REMOVED */
}

/* Enhanced Security Badges - No animation */
body.dark-mode .security-badge {
    /* animation: security-pulse 2s infinite; REMOVED */
    text-shadow: none; /* Removed text-shadow */
}

/* Enhanced Key Items - Simplified */
body.dark-mode .key-item {
    border: 1px solid var(--border-color);
    background-color: var(--card-bg); /* Consistent with card background */
    box-shadow: none; /* Removed box-shadow */
    transition: border-color 0.2s ease; /* Simplified transition */
}

body.dark-mode .key-item:hover {
    transform: none; /* Removed transform */
    border-color: var(--accent-color); /* Green border on hover */
    box-shadow: none;
}

/* Tab Button Enhancement - Simplified */
body.dark-mode .tab-btn.active {
    background-color: var(--accent-color); /* Terminal green background */
    color: var(--button-text); /* Black text for contrast */
    border-bottom-color: var(--accent-color);
    box-shadow: none;
    /* animation: tab-shift 3s infinite; REMOVED */
}
body.dark-mode .tab-btn:hover:not(.active) {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}


/* Switch slider enhancement - Simplified */
body.dark-mode .slider {
    background-color: #333; /* Dark grey for off state */
    box-shadow: none;
}

body.dark-mode input:checked + .slider {
    background-color: var(--accent-color); /* Terminal green for on state */
}

body.dark-mode .slider:before {
    box-shadow: none;
    background-color: #111; /* Darker circle */
}
body.dark-mode input:checked + .slider:before {
    background-color: #000; /* Black circle when active */
}


/* Status enhancement - No animation */
body.dark-mode .status.success,
body.dark-mode .status.warning,
body.dark-mode .status.error {
    /* animation: status-pulse 2s infinite; REMOVED */
    border-width: 1px;
    border-style: solid;
}
body.dark-mode .status.success { background-color: rgba(57, 255, 20, 0.1); border-color: var(--success-color); color: var(--success-color); }
body.dark-mode .status.warning { background-color: rgba(255, 255, 0, 0.1); border-color: var(--warning-color); color: var(--warning-color); }
body.dark-mode .status.error { background-color: rgba(255, 49, 49, 0.1); border-color: var(--error-color); color: var(--error-color); }


/* Loading animation enhancement - Simplified */
body.dark-mode .spinner {
    border: 3px solid rgba(224, 224, 224, 0.2); /* Lighter, subtle border */
    border-top-color: var(--accent-color); /* Terminal Green */
    /* animation: spin 1s ease-in-out infinite, color-shift 3s linear infinite; REMOVED color-shift */
    animation: spin 1s linear infinite; /* Kept spin animation */
}

/* Ensure base styles for .app-title are present if needed */
.app-title {
    font-size: 1.8rem;
    margin: 0;
    color: var(--text-color); /* Use text color for light mode */
    background: none;
}

/* Updated Dark Mode styles for elements previously animated or heavily styled */
body.dark-mode .app-title {
    color: var(--accent-color); /* Use accent color for solid text */
    text-shadow: none;
}

body.dark-mode .app-header::after {
    background: linear-gradient(90deg, transparent, var(--accent-color), transparent); /* Green accent line */
}

body.dark-mode .card::before { /* Top border highlight for card */
    background: var(--accent-color); /* Solid Green */
    height: 2px;
}

body.dark-mode .tab-btn:hover::after {
    background-color: var(--accent-color); /* Green underline on hover */
}

body.dark-mode input:focus, 
body.dark-mode textarea:focus, 
body.dark-mode select:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px var(--cyber-glow); /* Using the new subtle glow */
}

body.dark-mode .btn-secondary {
    border: 1px solid var(--accent-color); /* Green border */
    color: var(--accent-color); /* Green text */
    background-color: transparent;
}

body.dark-mode .btn-secondary:hover {
    background-color: rgba(57, 255, 20, 0.1); /* Slight green tint on hover */
    color: #39FF14; /* Brighter green text on hover */
}

/* Security Badges in Dark Mode - Static, no pulse */
body.dark-mode .security-badge {
    /* animation: securityPulse 2s infinite; REMOVED */
    transition: none;
}
body.dark-mode .security-badge.high { background-color: rgba(57, 255, 20, 0.1); color: var(--security-high); border: 1px solid var(--security-high); box-shadow: none; }
body.dark-mode .security-badge.medium { background-color: rgba(255, 255, 0, 0.1); color: var(--security-medium); border: 1px solid var(--security-medium); box-shadow: none; }
body.dark-mode .security-badge.low { background-color: rgba(255, 49, 49, 0.1); color: var(--security-low); border: 1px solid var(--security-low); box-shadow: none; }

/* Key Pair Badges in Dark Mode - Static */
body.dark-mode .key-pair-badge.full { background-color: rgba(57, 255, 20, 0.1); color: var(--security-high); border: 1px solid var(--security-high); box-shadow: none; }
body.dark-mode .key-pair-badge.private { background-color: rgba(255, 49, 49, 0.1); color: var(--security-low); border: 1px solid var(--security-low); box-shadow: none; }
body.dark-mode .key-pair-badge.public { background-color: rgba(255, 255, 0, 0.1); color: var(--security-medium); border: 1px solid var(--security-medium); box-shadow: none; }

body.dark-mode .private-key-btn {
    border: 1px solid var(--error-color) !important;
    color: var(--error-color) !important;
}
body.dark-mode .private-key-btn:hover {
    background-color: rgba(255, 49, 49, 0.2) !important;
    color: #FF3131 !important; /* Brighter red on hover */
}

/* Modal Content in Dark Mode */
body.dark-mode .modal-content {
    border: 1px solid var(--accent-color); /* Green border */
    box-shadow: none; /* Removed glow */
    background-color: var(--card-bg); /* Consistent with card backgrounds */
}

/* Primary button in dark mode (often used in modals) */
body.dark-mode .btn-primary {
    background-color: var(--accent-color); /* Green */
    color: #000000; /* Black text for contrast */
}
body.dark-mode .btn-primary:hover {
    background-color: #4CFF3A; /* Lighter green for hover */
}

/* Zero Keys button dark mode override */
body.dark-mode .btn-zero {
    background-color: var(--error-color); /* Neon Red */
    color: #FFFFFF; /* White text for contrast */
    border: 1px solid #FF0000; /* Brighter Red border */
}
body.dark-mode .btn-zero:hover {
    background-color: #FF5555; /* Lighter Neon Red */
}

/* Ensure general body styles and other non-dark-mode specific styles remain below */

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    margin: 0;
    padding: 0;
    transition: background-color 0.3s, color 0.3s;
    line-height: 1.6;
    position: relative;
    overflow-x: hidden;
}

/* Base container - Responsive container sizing */
.container {
    max-width: 600px;
    margin: 0 auto;
    padding: 20px;
    transition: max-width 0.3s ease-in-out;
}

.app-header {
    text-align: center;
    margin-bottom: 20px;
    position: relative;
}

/* .app-title is already defined above with dark mode considerations */

.app-subtitle {
    font-size: 0.9rem;
    margin: 0;
    padding-top: 2px;
    font-style: italic;
    color: var(--text-color);
    opacity: 0.8;
}

.app-header::after {
    content: '';
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
}

.card {
    background-color: var(--card-bg);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
    position: relative;
    overflow: hidden;
}

.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: linear-gradient(90deg, #33aaff, #0066cc); /* Default for light mode */
}
/* Dark mode card::before is handled by body.dark-mode .card::before */


.tabs {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    overflow-x: auto; /* Allow scrolling on small screens */
}

.tab-btn {
    background: none;
    border: none;
    padding: 10px 20px;
    font-size: 1rem;
    cursor: pointer;
    color: var(--text-color);
    border-bottom: 2px solid transparent;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
    white-space: nowrap; /* Prevent text wrapping */
}

.tab-btn.active {
    border-bottom: 2px solid var(--accent-color);
    color: var(--accent-color);
}
/* body.dark-mode .tab-btn.active is already defined */

.tab-btn::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 0;
    height: 2px;
    background-color: var(--accent-color);
    transition: width 0.3s;
}

.tab-btn:hover::after {
    width: 100%;
}
/* body.dark-mode .tab-btn:hover::after is already defined */

.tab-content {
    display: none !important;
}

.tab-content.active {
    display: block !important;
    /* animation: fadeIn 0.3s ease-in-out; REMOVED animation for performance */
}

/* @keyframes fadeIn { REMOVED
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
} */

.form-group {
    margin-bottom: 15px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
}

input, textarea, select {
    width: 100%;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--input-bg);
    color: var(--text-color);
    font-size: 1rem;
    box-sizing: border-box;
    transition: border-color 0.3s, box-shadow 0.3s;
}

input:focus, textarea:focus, select:focus {
    outline: none;
    border-color: var(--accent-color);
    box-shadow: 0 0 0 2px var(--cyber-glow); /* Default glow, dark mode overrides this */
}
/* body.dark-mode input:focus etc. is already defined */


/* Enhanced output textareas */
#encryptedOutput,
#decryptedOutput {
    min-height: 120px;
    background-color: var(--output-bg);
    color: var(--output-text);
    border-width: 1px;
    border-style: solid;
    border-color: var(--border-color);
    font-family: 'Consolas', 'Courier New', monospace;
    width: 100%;
    resize: vertical;
    padding: 15px;
    overflow-y: auto;
}

/* Make sure parent containers don't restrict width */
.form-group:has(#encryptedOutput),
.form-group:has(#decryptedOutput) {
    width: 100%;
}

/* Non :has() fallback for better browser compatibility */
#encrypt .form-group:nth-of-type(3),
#decrypt .form-group:nth-of-type(3) {
    width: 100%;
}

textarea {
    min-height: 100px;
    resize: vertical;
}

button {
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
    position: relative;
    overflow: hidden;
}

button:hover {
    background-color: var(--button-hover);
}
/* body.dark-mode button:hover is already defined */


button:active {
    transform: scale(0.98);
}

/* Removed ripple effect for performance */
button::after {
    display: none;
}
/* @keyframes ripple { REMOVED ... } */

.btn-group {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.btn-secondary {
    background-color: transparent;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
}
/* body.dark-mode .btn-secondary is already defined */

.btn-secondary:hover {
    background-color: rgba(0,0,0, 0.05); /* Subtle hover for light mode */
}
/* body.dark-mode .btn-secondary:hover is already defined */

.status {
    padding: 10px;
    border-radius: 8px;
    margin-top: 15px;
    display: none; /* Hidden by default */
}

.status.success {
    background-color: rgba(0, 204, 102, 0.1);
    color: var(--success-color);
    border: 1px solid var(--success-color);
    display: block;
}

.status.warning {
    background-color: rgba(240, 173, 78, 0.1);
    color: var(--warning-color);
    border: 1px solid var(--warning-color);
    display: block;
}

.status.error {
    background-color: rgba(204, 51, 0, 0.1);
    color: var(--error-color);
    border: 1px solid var(--error-color);
    display: block;
}
/* body.dark-mode .status styles are already defined */

.keys-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.keys-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 15px;
    width: 100%;
}

.key-form {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.key-item {
    background-color: var(--input-bg); /* Light mode uses input background */
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    height: 100%;
}
/* body.dark-mode .key-item is already defined */


.key-item-content {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.key-item h3 {
    margin-top: 0;
    margin-bottom: 10px;
}

.key-header {
    text-align: center;
    margin-bottom: 15px;
}

.key-actions {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin-top: auto;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

.key-actions button {
    flex: 1 1 auto;
    min-width: 80px;
    padding: 8px 12px;
    font-size: 0.9rem;
}

.key-meta {
    font-size: 0.9rem;
    color: #888; /* Consistent for both modes, or use var(--text-color) with opacity */
    margin-bottom: 5px;
}

.key-management-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
}

.key-management-buttons button {
    flex: 1 1 auto;
    min-width: 100px;
}

.btn-zero {
    background-color: #cc3300;
    color: white;
    margin-top: 20px;
    width: 100%;
    font-weight: bold;
    border: 1px solid #aa2200;
}
.btn-zero:hover {
    background-color: #ff3300;
}
/* body.dark-mode .btn-zero is already defined */


.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    display: none; /* Hidden by default */
}

.spinner {
    width: 50px;
    height: 50px;
    border: 5px solid rgba(255, 255, 255, 0.3); /* Default for light mode, or when overlay is on light bg */
    border-radius: 50%;
    border-top-color: var(--accent-color); /* Uses current accent color */
    animation: spin 1s linear infinite; /* Simplified animation */
}
/* body.dark-mode .spinner is already defined */

@keyframes spin {
    to { transform: rotate(360deg); }
}
/* @keyframes color-shift { REMOVED ... } */


.password-strength {
    height: 5px;
    border-radius: 5px;
    margin-top: 5px;
    transition: all 0.3s;
}
.password-strength.weak { background-color: var(--security-low); width: 30%; }
.password-strength.medium { background-color: var(--security-medium); width: 60%; }
.password-strength.strong { background-color: var(--security-high); width: 100%; }

.password-feedback {
    font-size: 0.8rem;
    margin-top: 5px;
    color: var(--text-color); /* Ensure it's readable in dark mode */
    opacity: 0.9;
}

.security-badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    margin-left: 8px;
    font-weight: bold;
}
.security-badge.high { background-color: rgba(0, 204, 102, 0.1); color: var(--security-high); border: 1px solid var(--security-high); }
.security-badge.medium { background-color: rgba(240, 173, 78, 0.1); color: var(--security-medium); border: 1px solid var(--security-medium); }
.security-badge.low { background-color: rgba(204, 51, 0, 0.1); color: var(--security-low); border: 1px solid var(--security-low); }
/* body.dark-mode .security-badge (static) is already defined */

/* @keyframes securityPulse { REMOVED ... } */


.key-pair-badge {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
    margin-top: 5px;
}
.key-pair-badge.full { background-color: rgba(0, 204, 102, 0.1); color: var(--security-high); border: 1px solid var(--security-high); }
.key-pair-badge.private { background-color: rgba(204, 51, 0, 0.1); color: var(--security-low); border: 1px solid var(--security-low); }
.key-pair-badge.public { background-color: rgba(240, 173, 78, 0.1); color: var(--security-medium); border: 1px solid var(--security-medium); }
/* body.dark-mode .key-pair-badge (static) is already defined */


.private-key-btn { /* Base style for light mode */
    border: 1px solid var(--error-color) !important;
    color: var(--error-color) !important;
}
.private-key-btn:hover {
    background-color: rgba(204, 51, 0, 0.1) !important;
}
/* body.dark-mode .private-key-btn is already defined */


.config-toggle {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}
.config-toggle label {
    display: inline;
    margin-bottom: 0;
}

.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}
.switch input { opacity: 0; width: 0; height: 0; }

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc; /* Light mode off */
    transition: .4s;
    border-radius: 24px;
}
.slider:before {
    position: absolute;
    content: "";
    height: 16px;
    width: 16px;
    left: 4px;
    bottom: 4px;
    background-color: white; /* Light mode handle */
    transition: .4s;
    border-radius: 50%;
}
input:checked + .slider { background-color: var(--accent-color); } /* Uses current accent */
input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
input:checked + .slider:before { transform: translateX(26px); }
/* body.dark-mode .slider styles are already defined */


.security-info {
    font-size: 0.9rem;
    padding: 10px;
    border-left: 3px solid var(--accent-color);
    background-color: rgba(0,0,0, 0.03); /* Very light grey for light mode */
    margin-bottom: 15px;
}
body.dark-mode .security-info {
    background-color: rgba(57, 255, 20, 0.05); /* Subtle green background */
    border-left-color: var(--accent-color); /* Green left border */
    color: var(--text-color);
}

.key-expiry {
    font-size: 0.8rem;
    color: var(--warning-color); /* Uses warning color */
    margin-top: 5px;
    font-style: italic;
}

#inactivityModal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    z-index: 1001;
    justify-content: center;
    align-items: center;
}
.modal-content { /* Base styles for modal, dark mode overrides parts of this */
    background-color: var(--card-bg);
    padding: 20px;
    border-radius: 12px;
    max-width: 400px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Light mode shadow */
    width: 90%; /* Added for responsiveness */
    position: relative; /* Added for positioning context if needed */
}
/* body.dark-mode .modal-content is already defined */

.timer {
    font-size: 2rem;
    margin: 20px 0;
    color: var(--warning-color);
}

#settings { display: none; } /* Base, active state is .tab-content.active */

.settings-section { margin-bottom: 20px; }
.settings-section h3 {
    margin-top: 0;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 5px;
}

.file-info {
    margin-top: 10px;
    font-size: 0.9rem;
    background-color: var(--input-bg);
    padding: 8px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}
.file-info-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.file-icon { margin-right: 8px; font-size: 1.2rem; }
.remove-file { cursor: pointer; color: var(--error-color); padding: 2px 6px; border-radius: 4px; margin-left: 8px; }
.remove-file:hover { background-color: rgba(204, 51, 0, 0.1); } /* Light mode hover */
body.dark-mode .remove-file:hover { background-color: rgba(255, 49, 49, 0.2); }


/* Password Modal Styles */
.modal { /* General modal styling, used by passwordModal too */
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 1001;
    justify-content: center;
    align-items: center;
}

.btn-primary { /* Base btn-primary, dark mode overrides */
    background-color: var(--accent-color);
    color: var(--button-text);
    border: none;
    border-radius: 8px;
    padding: 12px 20px;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
}
.btn-primary:hover {
    background-color: var(--button-hover);
}
/* body.dark-mode .btn-primary is already defined */


/* Mobile Optimization */
@media (max-width: 600px) {
    .container { padding: 15px; }
    .card { padding: 15px; }
    .app-title { font-size: 1.5rem; }
    .btn-group { flex-direction: column; }
    /* button { width: 100%; } This was too broad, specific buttons might need this */
    .btn-group button { width: 100%; } /* Apply to buttons within btn-group */
    .key-actions button { width: 100%; margin-bottom: 5px; }


    .tab-btn { padding: 10px 10px; font-size: 0.9rem; }
    .key-actions { flex-direction: column; }
}

@media (max-width: 767px) {
    .keys-container { flex-direction: column; }
    .key-form, .keys-list-container { width: 100%; }
}

/* Medium screens (tablets and small desktops) */
@media (min-width: 768px) {
    .container { max-width: 750px; }
    .app-title { font-size: 2rem; }
    .card { padding: 25px; }
    #encryptedOutput, #decryptedOutput { min-height: 150px; font-size: 1.05rem; }
    .keys-container { flex-direction: row; align-items: flex-start; }
    .key-form { width: 40%; position: sticky; top: 20px; }
    .keys-list-container { width: 60%; }
    .key-item h3 { font-size: 1.1rem; margin-top: 0; margin-bottom: 10px; word-break: break-word; }
}

/* Large screens (desktops and large tablets in landscape) */
@media (min-width: 1024px) {
    .container { max-width: 900px; }
    #encryptedOutput, #decryptedOutput { min-height: 180px; font-size: 1.1rem; padding: 18px; }
    #keys .card { display: flex; flex-wrap: wrap; gap: 20px; }
    #keys .card > h2, #keys .card > .security-info { width: 100%; }
    #keys .card > .form-group, #keys .card > button#generateKeyBtn { width: calc(40% - 10px); }
    #keys .card > div:has(#keysList) { width: calc(60% - 10px); margin-top: 0; }
    #keys .card > div:nth-last-child(3) { /* Fallback */ width: calc(60% - 10px); margin-top: 0; }
    #keys .card > .btn-group, #keys .card > div:has(#zeroKeysBtn) { width: 100%; }
    #encrypt .card, #decrypt .card { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    #encrypt .card > .form-group:first-child,
    #decrypt .card > .form-group:first-child,
    #encrypt .card > .form-group:has(#encryptedOutput),
    #decrypt .card > .form-group:has(#decryptedOutput),
    #encrypt .card > .form-group:nth-child(3), /* Fallback */
    #decrypt .card > .form-group:nth-child(3) /* Fallback */
    { grid-column: 1 / span 2; }
    #encrypt .card > button, #decrypt .card > button { grid-column: 1 / span 2; }
    #encrypt .card > .btn-group, #decrypt .card > .btn-group { grid-column: 1 / span 2; }
    #encrypt .card > #encryptStatus, #decrypt .card > #decryptStatus { grid-column: 1 / span 2; }
}

@media (min-width: 1200px) {
    .container { max-width: 1140px; }
    .keys-grid { grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); }
}

/* Extra large screens */
@media (min-width: 1440px) {
    .container { max-width: 1200px; }
    #encryptedOutput, #decryptedOutput { min-height: 220px; font-size: 1.15rem; padding: 20px; }
    #settings .card { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; }
    #settings .card > h2 { grid-column: 1 / span 2; }
    #settings .card > .btn-group { grid-column: 1 / span 2; justify-content: center; }
    #settings .card > #settingsStatus { grid-column: 1 / span 2; }
    #keysList { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; }

    @media (min-width: 1800px) {
        #encrypt .card, #decrypt .card { grid-template-columns: 1fr 1fr 1fr; }
        #encrypt .card > .form-group:first-child,
        #decrypt .card > .form-group:first-child,
        #encrypt .card > .form-group:has(#encryptedOutput),
        #decrypt .card > .form-group:has(#decryptedOutput),
        #encrypt .card > .form-group:nth-child(3), /* Fallback */
        #decrypt .card > .form-group:nth-child(3), /* Fallback */
        #encrypt .card > button, #decrypt .card > button,
        #encrypt .card > .btn-group, #decrypt .card > .btn-group,
        #encrypt .card > #encryptStatus, #decrypt .card > #decryptStatus
        { grid-column: 1 / span 3; }
    }
}

/* Ensure button groups stack properly on mobile but stay horizontal on larger screens */
/* This is already handled well by the (max-width: 600px) rule for .btn-group */
@media (min-width: 601px) {
    .btn-group { flex-direction: row; }
    .btn-group button { flex: 1; }
}


/* Print styles */
@media print {
    body { background-color: white; color: black; }
    body.dark-mode { /* Override dark mode for print */
        --bg-color: #ffffff;
        --text-color: #000000;
        --card-bg: #ffffff;
        --border-color: #dddddd;
        --input-bg: #ffffff;
        --output-bg: #f8f8f8;
        --output-text: #222222;
    }
    body.dark-mode .app-title { /* Ensure title is visible when printing from dark mode */
        background: none;
        color: #000000;
        text-shadow: none;
    }
    body.dark-mode .tab-btn.active {
        color: #000000; /* Black text for active tab in print */
        background: none;
    }
    body.dark-mode .security-info {
        background-color: #f0f0f0;
        border-left-color: #ccc;
        color: #000;
    }


    .card { box-shadow: none; border: 1px solid #ddd; }
    .btn-group, button, .tabs, .app-subtitle, .key-actions, .key-management-buttons, .config-toggle, #installContainer, .remove-file { display: none !important; }
    .container { max-width: 100%; padding: 0; }
    #encryptedOutput, #decryptedOutput { border: 1px solid #ddd; background-color: white; color: black; min-height: auto; }
    .key-item { page-break-inside: avoid; }
    .keys-grid { grid-template-columns: 1fr !important; } /* Single column for printing keys */
}
    </style>
</head>
<body>
    <div class="container">
        <div class="app-header">
            <h1 class="app-title">LC5</h1>
            <div class="app-subtitle">by elkmire</div>
            <p>Secure MSG.FILE option</p>
        </div>
        
        <div class="tabs">
            <button class="tab-btn active" data-tab="encrypt">Encrypt</button>
            <button class="tab-btn" data-tab="decrypt">Decrypt</button>
            <button class="tab-btn" data-tab="keys">Key Management</button>
            <button class="tab-btn" data-tab="settings">Settings</button>
        </div>
        
        <div class="tab-content active" id="encrypt">
            <div class="card">
                <div class="form-group">
                    <label for="encryptMessage">To Encrypt</label>
                    <textarea id="encryptMessage" placeholder="Free-type here or load file for encryption..."></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <button id="encryptBrowseBtn" class="btn-secondary">Browse Files</button>
                        <button id="clearEncryptMessageBtn" class="btn-secondary">Clear</button>
                        <input type="file" id="encryptFileInput" style="display: none;">
                    </div>
                    <div id="encryptFileInfo" style="display: none;" class="file-info">
                        <span><span class="file-icon">ðŸ“„</span> <span id="encryptFileName" class="file-info-name"></span></span>
                        <span class="remove-file" id="removeEncryptFile">Ã—</span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="encryptionKey">Encryption Key</label>
                    <select id="encryptionKey">
                        <option value="">Select a key...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="encryptObfKey">OBF Key</label>
                    <input type="text" id="encryptObfKey" placeholder="Optional*">
                </div>
                
                <div class="form-group" id="encryptionPasswordGroup" style="display: none;">
                    <label for="encryptionPassword">Key Password</label>
                    <input type="password" id="encryptionPassword" placeholder="Enter key password">
                </div>
                
                <button id="encryptBtn">Encrypt Data</button>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label for="encryptedOutput">Encrypted Data</label>
                    <textarea id="encryptedOutput" readonly></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="downloadEncryptedBtn" class="btn-secondary">Download Encrypted File</button>
                    <button id="copyEncryptedBtn" class="btn-secondary">Copy to Clipboard</button>
                    <button id="clearEncryptBtn" class="btn-secondary">Clear All</button>
                </div>
                
                <div id="encryptStatus" class="status"></div>
            </div>
        </div>
        
        <div class="tab-content" id="decrypt">
            <div class="card">
                <div class="form-group">
                    <label for="encryptedMessage">To Decrypt</label>
                    <textarea id="encryptedMessage" placeholder="Paste the encrypted data here or load encrypted data..."></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <button id="decryptBrowseBtn" class="btn-secondary">Browse Files</button>
                        <button id="clearEncryptedMessageBtn" class="btn-secondary">Clear</button>
                        <input type="file" id="decryptFileInput" style="display: none;">
                    </div>
                    <div id="decryptFileInfo" style="display: none;" class="file-info">
                        <span><span class="file-icon">ðŸ“„</span> <span id="decryptFileName" class="file-info-name"></span></span>
                        <span class="remove-file" id="removeDecryptFile">Ã—</span>
                    </div>
                </div>

                <div class="form-group">
                    <label for="decryptionKey">Decryption Key</label>
                    <select id="decryptionKey">
                        <option value="">Select a key...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="decryptObfKey">OBF Key</label>
                    <input type="text" id="decryptObfKey" placeholder="Optional*">
                </div>
                
                <div class="form-group" id="decryptionPasswordGroup" style="display: none;">
                    <label for="decryptionPassword">Key Password</label>
                    <input type="password" id="decryptionPassword" placeholder="Enter key password">
                </div>
                
                <button id="decryptBtn">Decrypt Data</button>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label for="decryptedOutput">Decrypted Data</label>
                    <textarea id="decryptedOutput" readonly></textarea>
                </div>
                
                <div class="btn-group">
                    <button id="downloadDecryptedBtn" class="btn-secondary">Download Decrypted File</button>
                    <button id="copyDecryptedBtn" class="btn-secondary">Copy to Clipboard</button>
                    <button id="clearDecryptBtn" class="btn-secondary">Clear All</button>
                </div>
                
                <div id="decryptStatus" class="status"></div>
            </div>
        </div>
        
        <div class="tab-content" id="keys">
            <div class="card">
                <h2>Key Management</h2>
                
                <div class="security-info">
                    <strong>Security Note:</strong> All keys are stored locally in your browser's protected storage and never sent to any server.
                </div>
                
                <div class="keys-container">
                    <div class="key-form">
                        <div class="form-group">
                            <label for="keyName">Key Name</label>
                            <input type="text" id="keyName" placeholder="e.g., enter crypto name">
                        </div>
                        
                        <div class="form-group">
                            <label for="keyType">Key Type</label>
                            <select id="keyType">
                                <option value="aes">AES-GCM (Symmetric) - 256 bits</option>
                                <option value="rsa">RSA-OAEP (Asymmetric) - 2048 bits</option>
                                <option value="rsa-4096">RSA-OAEP (Asymmetric) - 4096 bits</option>
                                <option value="ecc">ECC (Asymmetric) - P-256</option>
                                <option value="ecc-p384">ECC (Asymmetric) - P-384</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="keyExpiry">Key Expiration (Optional)</label>
                            <select id="keyExpiry">
                                <option value="">Never (Not Recommended)</option>
                                <option value="30">30 Days</option>
                                <option value="90">90 Days</option>
                                <option value="180">180 Days</option>
                                <option value="365">1 Year</option>
                            </select>
                        </div>
                        
                        <div class="form-group" id="keyPasswordGroup">
                            <label for="keyPassword">Key Password (Recommended)</label>
                            <input type="password" id="keyPassword" placeholder="Enter optional password">
                            <div id="passwordStrength" class="password-strength"></div>
                            <div id="passwordFeedback" class="password-feedback"></div>
                        </div>
                        
                        <div class="form-group" id="confirmKeyPasswordGroup">
                            <label for="confirmKeyPassword">Confirm Password</label>
                            <input type="password" id="confirmKeyPassword" placeholder="Confirm your password">
                        </div>
                        
                        <button id="generateKeyBtn">Generate New Key</button>
                        
                        <div class="key-management-buttons">
                            <button id="importKeyBtn" class="btn-secondary">Import Key</button>
                            <button id="exportAllKeysBtn" class="btn-secondary">Export State</button>
                            <button id="importStateBtn" class="btn-secondary">Import State</button>
                        </div>
        
                        <div style="text-align: center; margin-top: 20px;">
                            <button id="zeroKeysBtn" class="btn-zero">ZERO ALL KEYS</button>
                        </div>
                        
                        <div id="keyStatus" class="status"></div>
                    </div>
                    
                    <div class="keys-list-container">
                        <h3>Your Keys</h3>
                        <div id="keysList" class="keys-grid">
                            <!-- Keys will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="settings">
            <div class="card">
                <h2>Security Settings</h2>
<p> (Must SAVE for changes to take effect) <p>
                
                <div class="settings-section">
                    <h3>Storage Options</h3>
                    
                    <div class="config-toggle">
                        <label for="useIndexedDB">Use IndexedDB for key storage (more secure)</label>
                        <label class="switch">
                            <input type="checkbox" id="useIndexedDB" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="config-toggle">
                        <label for="sessionOnly">Session-only mode (keys aren't saved when browser closes)</label>
                        <label class="switch">
                            <input type="checkbox" id="sessionOnly">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>Security Parameters</h3>
                    
                    <div class="config-toggle">
                        <label for="enforcePwdProtection">Enforce password protection for keys</label>
                        <label class="switch">
                            <input type="checkbox" id="enforcePwdProtection">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="config-toggle">
                        <label for="enforceKeyExpiry">Enforce key expiration</label>
                        <label class="switch">
                            <input type="checkbox" id="enforceKeyExpiry">
                            <span class="slider"></span>
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label for="pbkdf2Iterations">PBKDF2 Iterations (higher = more secure but slower)</label>
                        <select id="pbkdf2Iterations">
                            <option value="100000">100,000 (Default)</option>
                            <option value="200000">200,000</option>
                            <option value="300000">300,000</option>
                            <option value="500000">500,000</option>
                        </select>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Appearance</h3>
                    
                    <div class="config-toggle">
                        <label for="darkMode">Dark Mode</label>
                        <label class="switch">
                            <input type="checkbox" id="darkMode">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Install App</h3>
                    <p>Installs PWA (must be Chromium-based browser or Safari for IOS)</p>
                    <div id="installContainer">
                        <button id="installBtn" class="btn-secondary">Install Lemonade App</button>
                        <p class="install-note" style="margin-top: 8px; font-size: 0.85rem; color: #888;">
                            (Button will be enabled when installation is available)
                        </p>
                    </div>
                    <div id="installStatus" class="status"></div>
                </div>

                <div class="btn-group">
                    <button id="saveSettingsBtn">Save Settings</button>
                    <button id="resetSettingsBtn" class="btn-secondary">Reset to Defaults</button>
                </div>
                
                <div id="settingsStatus" class="status"></div>
            </div>
        </div>
    </div>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
    </div>
    
    <script>
        // Secure Constants with proper bits for each algorithm
        const PBKDF2_CONFIG = {
            ITERATIONS: 100000,
            HASH: "SHA-256"
        };
        const AES_CONFIG = {
            KEY_LENGTH: 256,
            MODE: "AES-GCM",
            IV_LENGTH: 12, // bytes
            TAG_LENGTH: 128 // bits
        };
        const RSA_CONFIG = {
            KEY_SIZE: 2048,
            KEY_SIZE_4096: 4096,
            ALGORITHM: "RSA-OAEP",
            HASH: "SHA-256"
        };
        const ECC_CONFIG = {
            CURVE: "P-256",
            CURVE_P384: "P-384",
            ALGORITHM: "ECDH",
            KEY_DERIVATION: "HKDF",
            KDF_HASH: "SHA-256",
            ENC_ALGORITHM: "AES-GCM"
        };
        const SECURE_DELIMITER = "c1a9f5d3-c2a8-4c6f-8b1e-3e4d5a6b7c8d";

        
        // DB Constants
        const DB_NAME = "LemonadeSecureDB";
        const DB_VERSION = 1;
        const KEYS_STORE = "keys";
        const SETTINGS_STORE = "settings";
        
        // Security settings default values
        const DEFAULT_SETTINGS = {
            useIndexedDB: true,
            sessionOnly: false,
            enforcePwdProtection: false,
            enforceKeyExpiry: false,
            pbkdf2Iterations: 100000,
        };
        
        // Global variables
        let db = null;
        let keys = [];
        let appSettings = { ...DEFAULT_SETTINGS };
        
        // Elements
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        const encryptionKeySelect = document.getElementById('encryptionKey');
        const decryptionKeySelect = document.getElementById('decryptionKey');
        const keysList = document.getElementById('keysList');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const inactivityModal = document.getElementById('inactivityModal');
        const timeoutTimer = document.getElementById('timeoutTimer');
        
        // Memory protection and content validation utilities
        const safeMemory = {
            // Create a WeakMap to store sensitive data with automatic garbage collection
            sensitiveData: new WeakMap(),
            
            // Store sensitive data with a random key
            store: function(data) {
                const secureKey = { id: crypto.randomUUID() };
                this.sensitiveData.set(secureKey, data);
                return secureKey;
            },
            
            // Retrieve and optionally delete sensitive data
            retrieve: function(secureKey, deleteAfter = false) {
                if (!this.sensitiveData.has(secureKey)) return null;
                
                const data = this.sensitiveData.get(secureKey);
                
                if (deleteAfter) {
                    this.sensitiveData.delete(secureKey);
                }
                
                return data;
            },
            
            // Explicitly delete sensitive data
            delete: function(secureKey) {
                if (this.sensitiveData.has(secureKey)) {
                    this.sensitiveData.delete(secureKey);
                    return true;
                }
                return false;
            },
            
            // Securely clear all sensitive data
            clearAll: function() {
                this.sensitiveData = new WeakMap();
                // Force garbage collection if possible (not guaranteed)
                if (typeof window.gc === 'function') {
                    try {
                        window.gc();
                    } catch (e) {
                        console.log('Manual garbage collection not available');
                    }
                }
            }
        };
        
        const validator = {
            sanitizeHTML: function(text) {
                const element = document.createElement('div');
                element.textContent = text;
                return element.innerHTML;
            },
            
            validateInput: function(input, allowHTML = false) {
                // Reject null or undefined
                if (input === null || input === undefined) return '';
                
                // Convert to string if not already
                const str = String(input);
                
                // Return sanitized or raw based on allowHTML
                return allowHTML ? str : this.sanitizeHTML(str);
            },
            
            isValidKeyName: function(name) {
                return /^[A-Za-z0-9 ._-]{1,50}$/.test(name);
            },
            
            isValidEncryptedMessage: function(message) {
                return /^--LM--\s*[A-Za-z0-9+/=]+\s*--EM--$/s.test(message);
            },
            
            measurePasswordStrength: function(password) {
                // Default score is 0 (weak)
                let score = 0;
                
                // Skip empty passwords
                if (!password) return { score: 0, feedback: "Password is required" };
                
                // Check length (up to 5 points)
                const length = password.length;
                score += Math.min(5, Math.floor(length / 4));
                
                // Check complexity (up to 5 more points)
                if (/[a-z]/.test(password)) score += 1; // Has lowercase
                if (/[A-Z]/.test(password)) score += 1; // Has uppercase
                if (/[0-9]/.test(password)) score += 1; // Has number
                if (/[^A-Za-z0-9]/.test(password)) score += 2; // Has special char
                
                // Check for common patterns (subtract points)
                if (/^[a-zA-Z]+$/.test(password)) score -= 1; // Letters only
                if (/^[0-9]+$/.test(password)) score -= 1; // Numbers only
                if (/(.)\1{2,}/.test(password)) score -= 1; // Repeated characters
                
                // Get strength category and feedback
                let strengthCategory, feedback;
                
                if (score < 4) {
                    strengthCategory = "weak";
                    feedback = "Weak - Use a longer password with numbers and special characters";
                } else if (score < 8) {
                    strengthCategory = "medium";
                    feedback = "Medium - Add more variety or length for better security";
                } else {
                    strengthCategory = "strong";
                    feedback = "Strong - Good password!";
                }
                
                return { score, strengthCategory, feedback };
            }
        };

        // Helper to escape special characters for use in a regular expression
        // Define this ONCE in a scope accessible to functions that need it.
        const escapeRegex = (string) => {
            if (typeof string !== 'string') return ''; // Ensure it's a string
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Set up tabs - Using direct event binding for more reliable tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabId = btn.getAttribute('data-tab');
                    console.log('Tab button clicked:', tabId);
                    switchTab(tabId);
                });
            });

            // Setup dark mode toggle
            document.getElementById('darkMode').addEventListener('change', toggleDarkMode);
            // Check for saved theme preference
            const savedTheme = localStorage.getItem('LemonadeDarkMode');
            if (savedTheme === 'true') {
                document.getElementById('darkMode').checked = true;
                document.body.classList.add('dark-mode');
            }

            // Clear message buttons
            document.getElementById('clearEncryptMessageBtn').addEventListener('click', () => {
                clearEncryptFile(); 
            });
            document.getElementById('clearEncryptedMessageBtn').addEventListener('click', () => {
                clearDecryptFile(); 
            });
            
            // Set up database
            await initDatabase();
            
            // Load saved settings
            await loadSettings();
            
            // Initialize UI based on settings
            initSettingsUI();
            
            // Load stored keys
            await loadKeys();
            
            // Set up password strength meter
            document.getElementById('keyPassword').addEventListener('input', updatePasswordStrength);
            
            // Set up event listeners
            document.getElementById('encryptBtn').addEventListener('click', encryptMessage);
            document.getElementById('decryptBtn').addEventListener('click', decryptMessage);
            document.getElementById('generateKeyBtn').addEventListener('click', generateKey);
            document.getElementById('copyEncryptedBtn').addEventListener('click', () => copyToClipboard('encryptedOutput', 'encryptStatus'));
            document.getElementById('copyDecryptedBtn').addEventListener('click', () => copyToClipboard('decryptedOutput', 'decryptStatus'));
            document.getElementById('clearEncryptBtn').addEventListener('click', () => {
                document.getElementById('encryptMessage').value = '';
                document.getElementById('encryptedOutput').value = '';
                document.getElementById('encryptStatus').className = 'status';
                document.getElementById('encryptStatus').textContent = '';
                
                // Also clear any loaded files
                clearEncryptFile();
            });
            document.getElementById('clearDecryptBtn').addEventListener('click', () => {
                document.getElementById('encryptedMessage').value = '';
                document.getElementById('decryptedOutput').value = '';
                document.getElementById('decryptStatus').className = 'status';
                document.getElementById('decryptStatus').textContent = '';
                
                // Also clear any loaded files
                clearDecryptFile();
                
                // Clear any decrypted binary data if present
                window.decryptedBinaryData = null;
            });
            document.getElementById('importKeyBtn').addEventListener('click', importKey);
            document.getElementById('exportAllKeysBtn').addEventListener('click', exportAllKeys);
            document.getElementById('importStateBtn').addEventListener('click', importState);
            document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
            document.getElementById('resetSettingsBtn').addEventListener('click', resetSettings);
            document.getElementById('zeroKeysBtn').addEventListener('click', zeroAllKeys);
            
            // Key select changes
            encryptionKeySelect.addEventListener('change', handleEncryptionKeyChange);
            decryptionKeySelect.addEventListener('change', handleDecryptionKeyChange);

        });
        
        // Database Initialization
        async function initDatabase() {
            if (!window.indexedDB) {
                showStatus('keyStatus', 'Your browser doesn\'t support secure storage. Using less secure localStorage instead.', 'warning');
                appSettings.useIndexedDB = false;
                return;
            }
            
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onupgradeneeded = function(event) {
                    const db = event.target.result;
                    
                    // Create object stores if they don't exist
                    if (!db.objectStoreNames.contains(KEYS_STORE)) {
                        db.createObjectStore(KEYS_STORE, { keyPath: 'id' });
                    }
                    
                    if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                        db.createObjectStore(SETTINGS_STORE, { keyPath: 'id' });
                    }
                };
                
                request.onsuccess = function(event) {
                    db = event.target.result;
                    console.log('Database initialized successfully');
                    resolve();
                };
                
                request.onerror = function(event) {
                    console.error('Database error:', event.target.error);
                    showStatus('keyStatus', 'Database initialization failed. Using less secure localStorage instead.', 'warning');
                    appSettings.useIndexedDB = false;
                    resolve(); // Still resolve to continue app initialization
                };
            });
        }
        
        // Tab switching
        function switchTab(tabId) {
            console.log('Switching to tab:', tabId);
            
            // Update tab buttons
            tabBtns.forEach(btn => {
                if (btn.getAttribute('data-tab') === tabId) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Clear encrypt and decrypt forms whenever tabs are switched
            // Clear data in encrypt tab
            document.getElementById('encryptMessage').value = '';
            document.getElementById('encryptedOutput').value = '';
            document.getElementById('encryptStatus').className = 'status';
            document.getElementById('encryptStatus').textContent = '';
            document.getElementById('encryptionKey').value = '';
            document.getElementById('encryptionPassword').value = '';
            document.getElementById('encryptionPasswordGroup').style.display = 'none';
            clearEncryptFile();
            
            // Clear data in decrypt tab
            document.getElementById('encryptedMessage').value = '';
            document.getElementById('decryptedOutput').value = '';
            document.getElementById('decryptStatus').className = 'status';
            document.getElementById('decryptStatus').textContent = '';
            document.getElementById('decryptionKey').value = '';
            document.getElementById('decryptionPassword').value = '';
            document.getElementById('decryptionPasswordGroup').style.display = 'none';
            clearDecryptFile();
            window.decryptedBinaryData = null;
            
            // Directly access each tab content by ID to ensure all tabs are handled
            document.getElementById('encrypt').classList.remove('active');
            document.getElementById('decrypt').classList.remove('active');
            document.getElementById('keys').classList.remove('active');
            document.getElementById('settings').classList.remove('active');
            
            // Set the selected tab to active
            document.getElementById(tabId).classList.add('active');
        }
        
        // Show/hide loading overlay
        function setLoading(isLoading) {
            loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        }
        
        // Settings Management
        async function loadSettings() {
            if (appSettings.useIndexedDB && db) {
                try {
                    const settings = await getFromDatabase(SETTINGS_STORE, 'app-settings');
                    if (settings) {
                        appSettings = { ...DEFAULT_SETTINGS, ...settings };
                    }
                } catch (error) {
                    console.error('Error loading settings from database:', error);
                    // Fall back to localStorage
                    try {
                        const storedSettings = localStorage.getItem('LemonadeSettings');
                        if (storedSettings) {
                            appSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
                        }
                    } catch (localStorageError) {
                        console.error('Error loading settings from localStorage:', localStorageError);
                    }
                }
            } else {
                // Use localStorage
                try {
                    const storedSettings = localStorage.getItem('LemonadeSettings');
                    if (storedSettings) {
                        appSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
                    }
                } catch (error) {
                    console.error('Error loading settings from localStorage:', error);
                }
            }
            
            // Update PBKDF2 iterations from settings
            PBKDF2_CONFIG.ITERATIONS = appSettings.pbkdf2Iterations;
            
            return appSettings;
        }
        
        function initSettingsUI() {
            // Set UI elements based on loaded settings
            document.getElementById('useIndexedDB').checked = appSettings.useIndexedDB;
            document.getElementById('sessionOnly').checked = appSettings.sessionOnly;
            document.getElementById('enforcePwdProtection').checked = appSettings.enforcePwdProtection;
            document.getElementById('enforceKeyExpiry').checked = appSettings.enforceKeyExpiry;
            document.getElementById('pbkdf2Iterations').value = appSettings.pbkdf2Iterations;
        }
        
        async function saveSettings() {
            try {
                // Get values from UI
                appSettings.useIndexedDB = document.getElementById('useIndexedDB').checked;
                appSettings.sessionOnly = document.getElementById('sessionOnly').checked;
                appSettings.enforcePwdProtection = document.getElementById('enforcePwdProtection').checked;
                appSettings.enforceKeyExpiry = document.getElementById('enforceKeyExpiry').checked;
                appSettings.pbkdf2Iterations = parseInt(document.getElementById('pbkdf2Iterations').value);
                
                // Update PBKDF2 iterations
                PBKDF2_CONFIG.ITERATIONS = appSettings.pbkdf2Iterations;
                
                // Save settings to database or localStorage
                if (appSettings.useIndexedDB && db) {
                    await saveToDatabase(SETTINGS_STORE, { id: 'app-settings', ...appSettings });
                } else {
                    localStorage.setItem('LemonadeSettings', JSON.stringify(appSettings));
                }
                
                showStatus('settingsStatus', 'Settings saved successfully', 'success');
            } catch (error) {
                console.error('Error saving settings:', error);
                showStatus('settingsStatus', 'Error saving settings: ' + error.message, 'error');
            }
        }
        
        function resetSettings() {
            const confirmReset = confirm('Are you sure you want to reset all settings to defaults?');
            if (!confirmReset) return;
            
            appSettings = { ...DEFAULT_SETTINGS };
            initSettingsUI();
            saveSettings();
        }
        
        // Password strength meter
        function updatePasswordStrength() {
            const password = document.getElementById('keyPassword').value;
            const strength = validator.measurePasswordStrength(password);
            
            const strengthElement = document.getElementById('passwordStrength');
            const feedbackElement = document.getElementById('passwordFeedback');
            
            // Clear existing classes
            strengthElement.className = 'password-strength';
            
            if (password) {
                // Add class based on strength
                strengthElement.classList.add(strength.strengthCategory);
                
                // Update feedback
                feedbackElement.textContent = strength.feedback;
            } else {
                feedbackElement.textContent = '';
            }
        }
        
        // Key Management Functions
        async function loadKeys() {
            try {
                // Clear existing keys
                keys = [];
                
                if (appSettings.useIndexedDB && db) {
                    // Load from IndexedDB
                    const storedKeys = await getAllFromDatabase(KEYS_STORE);
                    if (storedKeys && storedKeys.length > 0) {
                        keys = storedKeys;
                    }
                } else {
                    // Load from localStorage
                    const storedKeys = localStorage.getItem('LemonadeKeys');
                    if (storedKeys) {
                        keys = JSON.parse(storedKeys);
                    }
                }
                
                // Check for expired keys and update UI
                checkExpiredKeys();
                updateKeysList();
                updateKeySelects();
            } catch (error) {
                console.error('Error loading keys:', error);
                showStatus('keyStatus', 'Error loading keys: ' + error.message, 'error');
            }
        }
        
        async function saveKeys() {
            try {
                if (appSettings.sessionOnly) {
                    // In session-only mode, we keep keys in memory but don't persist them
                    console.log('Session-only mode: Keys not saved persistently');
                } else if (appSettings.useIndexedDB && db) {
                    // Save to IndexedDB - first clear the store
                    await clearDatabase(KEYS_STORE);
                    
                    // Then add all keys
                    for (const keyData of keys) {
                        await saveToDatabase(KEYS_STORE, keyData);
                    }
                } else {
                    // Save to localStorage
                    localStorage.setItem('LemonadeKeys', JSON.stringify(keys));
                }
                
                // Update UI
                updateKeysList();
                updateKeySelects();
            } catch (error) {
                console.error('Error saving keys:', error);
                showStatus('keyStatus', 'Error saving keys: ' + error.message, 'error');
            }
        }
        
        function checkExpiredKeys() {
            const now = new Date();
            const expiredKeyIds = [];
            
            // Check each key for expiration
            keys.forEach(keyData => {
                if (keyData.expiry) {
                    const expiryDate = new Date(keyData.expiry);
                    if (expiryDate < now) {
                        expiredKeyIds.push(keyData.id);
                    }
                }
            });
            
            // Remove expired keys
            if (expiredKeyIds.length > 0) {
                keys = keys.filter(key => !expiredKeyIds.includes(key.id));
                saveKeys();
                showStatus('keyStatus', `${expiredKeyIds.length} expired key(s) removed for security`, 'warning');
            }
        }
        
        async function generateKey() {
            try {
                setLoading(true);
                
                const keyName = document.getElementById('keyName').value.trim();
                const keyType = document.getElementById('keyType').value;
                const keyPassword = document.getElementById('keyPassword').value;
                const confirmKeyPassword = document.getElementById('confirmKeyPassword').value;
                const keyExpiry = document.getElementById('keyExpiry').value;
                
                // Validate key name
                if (!keyName) {
                    showStatus('keyStatus', 'Please enter a key name', 'error');
                    return;
                }
                
                if (!validator.isValidKeyName(keyName)) {
                    showStatus('keyStatus', 'Key name can only contain letters, numbers, spaces, and basic punctuation (._-)', 'error');
                    return;
                }
                
                // Check password if enforced in settings
                if (appSettings.enforcePwdProtection && !keyPassword) {
                    showStatus('keyStatus', 'Password protection is required by your security settings', 'error');
                    return;
                }
                
                // Check password strength
                if (keyPassword) {
                    const strength = validator.measurePasswordStrength(keyPassword);
                    if (strength.score < 4) {
                        showStatus('keyStatus', 'Please use a stronger password: ' + strength.feedback, 'error');
                        return;
                    }
                    
                    // Confirm password match
                    if (keyPassword !== confirmKeyPassword) {
                        showStatus('keyStatus', 'Passwords do not match', 'error');
                        return;
                    }
                }
                
                // Check key expiry if enforced
                if (appSettings.enforceKeyExpiry && !keyExpiry) {
                    showStatus('keyStatus', 'Key expiration is required by your security settings', 'error');
                    return;
                }
                
                // Prepare key data structure
                const keyData = {
                    id: crypto.randomUUID(),
                    name: keyName,
                    type: keyType,
                    created: new Date().toISOString()
                };
                
                // Set expiry date if specified
                if (keyExpiry) {
                    const expiryDays = parseInt(keyExpiry);
                    const expiryDate = new Date();
                    expiryDate.setDate(expiryDate.getDate() + expiryDays);
                    keyData.expiry = expiryDate.toISOString();
                }
                
                // Identify if this is an asymmetric key
                const isAsymmetric = keyType === 'rsa' || keyType === 'rsa-4096' || 
                                    keyType === 'ecc' || keyType === 'ecc-p384';
                
                // For asymmetric keys, set flags to indicate it has both public and private parts
                if (isAsymmetric) {
                    keyData.hasPublic = true;
                    keyData.hasPrivate = true;
                    // Use the key ID as the pairing ID for newly generated key pairs
                    keyData.pairedKeyId = keyData.id;
                }
                
                // Generate the actual cryptographic key based on type
                if (keyType === 'aes') {
                    // For AES symmetric encryption
                    await generateAESKey(keyData, keyPassword);
                } else if (keyType === 'rsa') {
                    // For RSA 2048-bit encryption
                    await generateRSAKey(keyData, keyPassword, RSA_CONFIG.KEY_SIZE);
                } else if (keyType === 'rsa-4096') {
                    // For RSA 4096-bit encryption
                    await generateRSAKey(keyData, keyPassword, RSA_CONFIG.KEY_SIZE_4096);
                } else if (keyType === 'ecc') {
                    // For ECC P-256 encryption
                    await generateECCKey(keyData, keyPassword, ECC_CONFIG.CURVE);
                } else if (keyType === 'ecc-p384') {
                    // For ECC P-384 encryption
                    await generateECCKey(keyData, keyPassword, ECC_CONFIG.CURVE_P384);
                }
                
                keys.push(keyData);
                await saveKeys();
                
                // Clear form fields
                document.getElementById('keyName').value = '';
                document.getElementById('keyPassword').value = '';
                document.getElementById('confirmKeyPassword').value = '';
                document.getElementById('passwordStrength').className = 'password-strength';
                document.getElementById('passwordFeedback').textContent = '';
                
                const keyTypeDisplay = getKeyTypeDisplay(keyData);
                showStatus('keyStatus', `${keyTypeDisplay} key "${keyName}" generated successfully`, 'success');
            } catch (error) {
                console.error('Error generating key:', error);
                showStatus('keyStatus', 'Error generating key: ' + error.message, 'error');
            } finally {
                setLoading(false);
            }
        }

        function getPairedKeyIds(keyData) {
            // If this key is already paired, return the stored pair ID
            if (keyData.pairedKeyId) return keyData.pairedKeyId;
            
            // If this is a newly generated key, use its ID as the pair ID
            if (keyData.hasPrivate && keyData.hasPublic) return keyData.id;
            
            // For imported keys without explicit pairing, check for potential matches
            if ((keyData.type === 'rsa' || keyData.type === 'rsa-4096' || 
                keyData.type === 'ecc' || keyData.type === 'ecc-p384') && 
                (keyData.hasPublic || keyData.hasPrivate)) {
                
                const possiblePairs = keys.filter(k => 
                    k.id !== keyData.id && 
                    k.type === keyData.type && 
                    ((keyData.hasPublic && k.hasPrivate) || (keyData.hasPrivate && k.hasPublic)) &&
                    // For RSA, check modulus; for ECC, could check curve points
                    // This is a simplified check - would need more robust comparison in production
                    (k.publicKeyHash && keyData.publicKeyHash && k.publicKeyHash === keyData.publicKeyHash)
                );
                
                if (possiblePairs.length > 0) {
                    return possiblePairs[0].id;
                }
            }
            
            return null;
        }

        function zeroAllKeys() {
            // Check if there are any keys to delete
            if (keys.length === 0) {
                showStatus('keyStatus', 'No keys to delete', 'warning');
                return;
            }
            
            // Show confirmation dialog
            const confirmZero = confirm('WARNING: This will permanently delete ALL your encryption keys. This action CANNOT be undone.\n\nAre you absolutely sure you want to continue?');
            
            if (confirmZero) {
                // User confirmed, delete all keys
                const keyCount = keys.length;
                
                // Clear keys array
                keys = [];
                
                // Clear from storage
                if (appSettings.useIndexedDB && db) {
                    clearDatabase(KEYS_STORE)
                        .then(() => {
                            console.log('All keys cleared from database');
                        })
                        .catch(error => {
                            console.error('Error clearing keys from database:', error);
                        });
                } else {
                    localStorage.removeItem('LemonadeKeys');
                }
                
                // Update UI
                updateKeysList();
                updateKeySelects();
                
                // Show status message
                showStatus('keyStatus', `All keys (${keyCount}) have been permanently deleted`, 'success');
            } else {
                // User canceled
                showStatus('keyStatus', 'Key deletion canceled', 'info');
            }
        }
        
        async function generateAESKey(keyData, keyPassword) {
            // Generate a random AES key
            const key = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true, // extractable
                ['encrypt', 'decrypt']
            );
            
            // Export the key to raw format
            const rawKey = await window.crypto.subtle.exportKey('raw', key);
            
            // Convert to base64 for storage
            keyData.key = arrayBufferToBase64(rawKey);
            keyData.algorithm = AES_CONFIG.MODE;
            keyData.length = AES_CONFIG.KEY_LENGTH;
            
            // If password provided, encrypt the key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }
        
        async function generateRSAKey(keyData, keyPassword, keySize) {
            // For RSA, generate a key pair
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: RSA_CONFIG.ALGORITHM,
                    modulusLength: keySize,
                    publicExponent: new Uint8Array([0x01, 0x00, 0x01]), // 65537
                    hash: RSA_CONFIG.HASH
                },
                true, // extractable
                ['encrypt', 'decrypt']
            );
            
            // Export the public key
            const publicKey = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            
            // Export the private key
            const privateKey = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            
            // Convert to base64 for storage
            keyData.publicKey = arrayBufferToBase64(publicKey);
            keyData.privateKey = arrayBufferToBase64(privateKey);
            keyData.algorithm = RSA_CONFIG.ALGORITHM;
            keyData.length = keySize;
            
            // Compute a hash of the public key for pairing purposes
            const publicKeyHash = await computeKeyHash(publicKey);
            keyData.publicKeyHash = publicKeyHash;
            
            // If password provided, encrypt the private key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }
        
        async function generateECCKey(keyData, keyPassword, curve) {
            // For ECC, generate a key pair
            const keyPair = await window.crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                true, // extractable
                ['deriveKey', 'deriveBits']
            );
            
            // Export the public key
            const publicKey = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
            
            // Export the private key
            const privateKey = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
            
            // Convert to base64 for storage
            keyData.publicKey = arrayBufferToBase64(publicKey);
            keyData.privateKey = arrayBufferToBase64(privateKey);
            keyData.algorithm = 'ECDH';
            keyData.curve = curve;
            
            // Compute a hash of the public key for pairing purposes
            const publicKeyHash = await computeKeyHash(publicKey);
            keyData.publicKeyHash = publicKeyHash;
            
            // If password provided, encrypt the private key
            if (keyPassword) {
                await encryptKeyWithPassword(keyData, keyPassword);
            }
        }

        async function computeKeyHash(keyBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', keyBuffer);
            return arrayBufferToBase64(hashBuffer);
        }
        
        async function encryptKeyWithPassword(keyData, password) {
            // Generate a salt for PBKDF2
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            keyData.salt = arrayBufferToBase64(salt);
            
            // Derive a key from the password
            const derivedKey = await deriveKeyFromPassword(password, salt);
            
            // Generate an IV for encryption
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            keyData.iv = arrayBufferToBase64(iv);
            
            if (keyData.type === 'aes') {
                // Encrypt the AES key
                const encryptedKey = await encryptWithDerivedKey(
                    derivedKey,
                    base64ToArrayBuffer(keyData.key),
                    iv
                );
                
                // Replace the clear key with the encrypted one
                keyData.key = arrayBufferToBase64(encryptedKey);
                keyData.protected = true;
            } else {
                // For asymmetric keys (RSA, ECC) - encrypt the private key
                const encryptedPrivateKey = await encryptWithDerivedKey(
                    derivedKey,
                    base64ToArrayBuffer(keyData.privateKey),
                    iv
                );
                
                // Replace the clear private key with the encrypted one
                keyData.privateKey = arrayBufferToBase64(encryptedPrivateKey);
                keyData.protected = true;
            }
        }
        
        async function decryptKeyWithPassword(keyData, password) {
            try {
                // Validate inputs
                if (!keyData || !password) {
                    throw new Error('Key data and password are required');
                }
                
                if (!keyData.salt || !keyData.iv) {
                    throw new Error('Key is missing salt or IV data');
                }
                
                // Derive the key from password and salt
                const salt = base64ToArrayBuffer(keyData.salt);
                const derivedKey = await deriveKeyFromPassword(password, salt);
                
                // Get the IV
                const iv = base64ToArrayBuffer(keyData.iv);
                
                // Create a new object to avoid modifying the original
                const decryptedKeyData = { ...keyData };
                
                // Add safety check for the key type
                if (keyData.type === 'aes') {
                    if (!keyData.key) {
                        throw new Error('Missing encrypted key data');
                    }
                    
                    // Decrypt the AES key
                    const decryptedKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.key),
                        iv
                    );
                    
                    // Store the decrypted key
                    decryptedKeyData.key = arrayBufferToBase64(decryptedKey);
                    
                    // Import the key to CryptoKey object for actual use
                    decryptedKeyData._cryptoKey = await importAESKey(decryptedKey);
                } else if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                    if (!keyData.privateKey) {
                        throw new Error('Missing encrypted private key data');
                    }
                    
                    // Decrypt the RSA private key
                    const decryptedPrivateKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.privateKey),
                        iv
                    );
                    
                    // Store the decrypted private key
                    decryptedKeyData.privateKey = arrayBufferToBase64(decryptedPrivateKey);
                    
                    // Import the keys to CryptoKey objects
                    decryptedKeyData._privateKey = await importRSAPrivateKey(
                        decryptedPrivateKey,
                        keyData.length || RSA_CONFIG.KEY_SIZE
                    );
                    
                    if (keyData.publicKey) {
                        decryptedKeyData._publicKey = await importRSAPublicKey(
                            base64ToArrayBuffer(keyData.publicKey),
                            keyData.length || RSA_CONFIG.KEY_SIZE
                        );
                    }
                } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                    if (!keyData.privateKey) {
                        throw new Error('Missing encrypted private key data');
                    }
                    
                    // Decrypt the ECC private key
                    const decryptedPrivateKey = await decryptWithDerivedKey(
                        derivedKey,
                        base64ToArrayBuffer(keyData.privateKey),
                        iv
                    );
                    
                    // Store the decrypted private key
                    decryptedKeyData.privateKey = arrayBufferToBase64(decryptedPrivateKey);
                    
                    // Import the keys to CryptoKey objects
                    decryptedKeyData._privateKey = await importECCPrivateKey(
                        decryptedPrivateKey,
                        keyData.curve || ECC_CONFIG.CURVE
                    );
                    
                    if (keyData.publicKey) {
                        decryptedKeyData._publicKey = await importECCPublicKey(
                            base64ToArrayBuffer(keyData.publicKey),
                            keyData.curve || ECC_CONFIG.CURVE
                        );
                    }
                } else {
                    throw new Error('Unsupported key type: ' + keyData.type);
                }
                
                // Store the decrypted key data securely in memory
                return safeMemory.store(decryptedKeyData);
            } catch (error) {
                console.error('Decryption error:', error);
                throw new Error('Incorrect password or corrupted private key');
            }
        }
        
        function updateKeysList() {
            keysList.innerHTML = '';
            
            if (keys.length === 0) {
                keysList.innerHTML = '<p>No keys available. Generate or import a key to get started.</p>';
                return;
            }
            
            keys.forEach(keyData => {
                const keyItem = document.createElement('div');
                keyItem.className = 'key-item';
                
                const keyTypeDisplay = getKeyTypeDisplay(keyData);
                const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                
                // Determine key pair status badge
                let keyPairBadge = '';
                if (keyData.type === 'aes') {
                    keyPairBadge = ''; // Don't show for symmetric keys
                } else if (keyData.hasPrivate && keyData.hasPublic) {
                    keyPairBadge = '<span class="key-pair-badge full">FULL KEY PAIR</span>';
                } else if (keyData.hasPrivate) {
                    keyPairBadge = '<span class="key-pair-badge private">PRIVATE KEY</span>';
                } else if (keyData.hasPublic) {
                    keyPairBadge = '<span class="key-pair-badge public">PUBLIC KEY</span>';
                }
                
                let securityBadge = '';
                
                // Determine security level
                let securityLevel = determineKeySecurityLevel(keyData);
                
                securityBadge = `<span class="security-badge ${securityLevel}">${securityLevel.toUpperCase()}</span>`;
                
                // Calculate expiry date and display if present
                let expiryInfo = '';
                if (keyData.expiry) {
                    const expiryDate = new Date(keyData.expiry);
                    const daysToExpiry = Math.ceil((expiryDate - new Date()) / (1000 * 60 * 60 * 24));
                    expiryInfo = `<div class="key-expiry">Expires in ${daysToExpiry} days (${expiryDate.toLocaleDateString()})</div>`;
                }
                
                // Determine which buttons to show based on key type
                let keyActions = '';
                
                // Only show "Export Public" for asymmetric keys with public parts
                if (keyData.type === 'aes') {
                    keyActions += `<button class="btn-secondary" onclick="exportKey('${keyData.id}')">Export</button>`;
                } else if (keyData.hasPublic) {
                    keyActions += `<button class="btn-secondary" onclick="exportKey('${keyData.id}')">Export Public</button>`;
                }
                
                // Add private key export button for asymmetric keys that have private parts
                if (keyData.type !== 'aes' && keyData.hasPrivate) {
                    keyActions += `<button class="btn-secondary private-key-btn" onclick="exportPrivateKey('${keyData.id}')">Private Key</button>`;
                }
                
                keyActions += `<button class="btn-secondary" onclick="deleteKey('${keyData.id}')">Delete</button>`;
                
                keyItem.innerHTML = `
                    <div class="key-item-content">
                        <div class="key-header">
                            <h3>${validator.sanitizeHTML(keyData.name)} (${keyTypeDisplay}${protectedBadge}) ${securityBadge}</h3>
                            ${keyPairBadge}
                        </div>
                        <div class="key-meta">Created: ${new Date(keyData.created).toLocaleString()}</div>
                        <div class="key-meta">Algorithm: ${keyData.algorithm || ''} ${keyData.length ? keyData.length + ' bits' : keyData.curve || ''}</div>
                        ${expiryInfo}
                        <div class="key-actions">
                            ${keyActions}
                        </div>
                    </div>
                `;
                
                keysList.appendChild(keyItem);
            });
        }
        
        function getKeyTypeDisplay(keyData) {
            if (keyData.type === 'aes') {
                return 'AES';
            } else if (keyData.type === 'rsa') {
                return 'RSA-2048';
            } else if (keyData.type === 'rsa-4096') {
                return 'RSA-4096';
            } else if (keyData.type === 'ecc') {
                return 'ECC-P256';
            } else if (keyData.type === 'ecc-p384') {
                return 'ECC-P384';
            }
            return keyData.type.toUpperCase();
        }
        
        function updateKeySelects() {
            // Clear existing options
            encryptionKeySelect.innerHTML = '<option value="">Select a key...</option>';
            decryptionKeySelect.innerHTML = '<option value="">Select a key...</option>';
            
            // Add options for encryption (symmetric and public keys only)
            keys.forEach(keyData => {
                // For encryption, include symmetric keys and asymmetric public keys
                if (keyData.type === 'aes' || keyData.hasPublic) {
                    const option = document.createElement('option');
                    option.value = keyData.id;
                    
                    const keyTypeDisplay = getKeyTypeDisplay(keyData);
                    const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                    
                    let keyTypeBadge = '';
                    if (keyData.type !== 'aes') {
                        keyTypeBadge = keyData.hasPrivate && keyData.hasPublic ? ' [Full Pair]' : ' [Public]';
                    }
                    
                    option.text = `${keyData.name} (${keyTypeDisplay}${keyTypeBadge}${protectedBadge})`;
                    
                    encryptionKeySelect.appendChild(option);
                }
            });
            
            // Add options for decryption (symmetric and private keys only)
            keys.forEach(keyData => {
                // For decryption, include symmetric keys and asymmetric private keys
                if (keyData.type === 'aes' || keyData.hasPrivate) {
                    const option = document.createElement('option');
                    option.value = keyData.id;
                    
                    const keyTypeDisplay = getKeyTypeDisplay(keyData);
                    const protectedBadge = keyData.protected ? ' ðŸ”’' : '';
                    
                    let keyTypeBadge = '';
                    if (keyData.type !== 'aes') {
                        keyTypeBadge = keyData.hasPrivate && keyData.hasPublic ? ' [Full Pair]' : ' [Private]';
                    }
                    
                    option.text = `${keyData.name} (${keyTypeDisplay}${keyTypeBadge}${protectedBadge})`;
                    
                    decryptionKeySelect.appendChild(option);
                }
            });
        }
        
        function handleEncryptionKeyChange() {
            const keyId = encryptionKeySelect.value;
            if (!keyId) {
                document.getElementById('encryptionPasswordGroup').style.display = 'none';
                return;
            }
            
            // Find the selected key
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) return;
            
            // Show password field if key is protected
            document.getElementById('encryptionPasswordGroup').style.display = keyData.protected ? 'block' : 'none';
        }
        
        function handleDecryptionKeyChange() {
            const keyId = decryptionKeySelect.value;
            if (!keyId) {
                document.getElementById('decryptionPasswordGroup').style.display = 'none';
                return;
            }
            
            // Find the selected key
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) return;
            
            // Show password field if key is protected
            document.getElementById('decryptionPasswordGroup').style.display = keyData.protected ? 'block' : 'none';
        }
        
        async function encryptMessage() {
            try {
                let messageBuffer;
                let outputFileName = '';
                
                if (encryptFileData) {
                    // File encryption
                    messageBuffer = encryptFileData;
                    // Generate random filename with .lmn extension
                    outputFileName = generateRandomFileName(6) + '.lmn';
                } else {
                    // Text encryption
                    const message = document.getElementById('encryptMessage').value;
                    if (!message) {
                        showStatus('encryptStatus', 'Please enter a message or add a file to encrypt', 'error');
                        return;
                    }
                    messageBuffer = new TextEncoder().encode(message);
                }
                
                const keyId = document.getElementById('encryptionKey').value;
                const keyPassword = document.getElementById('encryptionPassword').value;
                let obfKey = document.getElementById('encryptObfKey').value; // Get OBF Key

                // Apply XOR cipher if OBF key is present
                if (obfKey) {
                    messageBuffer = xorCipher(messageBuffer, obfKey);
                }

                if (!keyId) {
                    showStatus('encryptStatus', 'Please select an encryption key', 'error');
                    return;
                }
                
                setLoading(true);
                
                // Find the selected key
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    showStatus('encryptStatus', 'Key not found', 'error');
                    setLoading(false); // Ensure loading stops
                    return;
                }
                
                // Check if key is password-protected
                let decryptedKeyRef = null;
                let actualKeyData = keyData;
                
                if (keyData.protected) {
                    if (!keyPassword) {
                        showStatus('encryptStatus', 'Password required for this key', 'error');
                        setLoading(false); // Ensure loading stops
                        return;
                    }
                    
                    try {
                        decryptedKeyRef = await decryptKeyWithPassword(keyData, keyPassword);
                        actualKeyData = safeMemory.retrieve(decryptedKeyRef);
                        if (!actualKeyData) {
                             throw new Error('Failed to retrieve decrypted key from memory.');
                        }
                    } catch (error) {
                        showStatus('encryptStatus', 'Failed to decrypt key: ' + error.message, 'error');
                        setLoading(false);
                        return;
                    }
                }
                
                // Encrypt using the enhanced functions
                let encryptionResult = await encryptData(messageBuffer, actualKeyData);
                
                // Clean up sensitive data if we decrypted a protected key
                if (decryptedKeyRef) {
                    safeMemory.delete(decryptedKeyRef);
                }
                
                // Add file information if encrypting a file
                if (encryptFileData) {
                    // Store file info in the metadata
                    encryptionResult.fileName = encryptFileName;
                    encryptionResult.fileSize = encryptFileData.byteLength;
                    encryptionResult.isFile = true;
                }
                
                // Create the final formatted message, passing the obfKey
                const encryptedOutput = createEncryptedMessageString(encryptionResult, obfKey); 
                
                document.getElementById('encryptedOutput').value = encryptedOutput;
                
                // Store the output file name for download
                document.getElementById('downloadEncryptedBtn').setAttribute('data-filename', outputFileName);
                
                showStatus('encryptStatus', 'Message encrypted successfully', 'success');
            } catch (error) {
                console.error('Encryption error:', error);
                showStatus('encryptStatus', 'Encryption error: ' + error.message, 'error');
            } finally {
                // Clear password field for security
                document.getElementById('encryptionPassword').value = '';
                setLoading(false);
            }
        }
        
        async function encryptWithAES(messageBuffer, keyData) {
            try {
                // 1. Generate a random IV for message encryption
                const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
                
                // 2. Import the encryption key
                let cryptoKey;
                if (keyData._cryptoKey) {
                    cryptoKey = keyData._cryptoKey;
                } else {
                    const keyBuffer = base64ToArrayBuffer(keyData.key);
                    cryptoKey = await window.crypto.subtle.importKey(
                        'raw',
                        keyBuffer,
                        { 
                            name: AES_CONFIG.MODE,
                            length: AES_CONFIG.KEY_LENGTH
                        },
                        false,
                        ['encrypt']
                    );
                }
                
                // 3. Encrypt the actual message with AES-GCM
                const encryptedData = await window.crypto.subtle.encrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: iv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    cryptoKey,
                    messageBuffer
                );
                
                // 4. Create metadata object
                const metadata = {
                    k: keyData.id,      // keyId
                    t: new Date().toISOString(), // timestamp
                    a: AES_CONFIG.MODE,  // algorithm
                };

                // Add file metadata if we're encrypting a file
                if (encryptFileData && encryptFileName) {
                    metadata.f = {
                        n: encryptFileName,   // filename
                        s: encryptFileData.byteLength  // file size
                    };
                }
                
                // 5. Convert metadata to buffer
                const metadataBuffer = new TextEncoder().encode(JSON.stringify(metadata));
                
                // 6. Generate a random IV for metadata encryption
                const metadataIv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
                
                // 7. Generate a separate key for metadata encryption
                const metadataKey = await window.crypto.subtle.generateKey(
                    {
                        name: AES_CONFIG.MODE,
                        length: AES_CONFIG.KEY_LENGTH
                    },
                    true, // extractable
                    ['encrypt']
                );
                
                // 8. Encrypt the metadata
                const encryptedMetadata = await window.crypto.subtle.encrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: metadataIv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    metadataKey,
                    metadataBuffer
                );
                
                // 9. Export the metadata key
                const exportedMetadataKey = await window.crypto.subtle.exportKey('raw', metadataKey);
                
                // 10. Construct the buffer with a simplified structure:
                // [struct_version(1B)][metadataIv(12B)][metadataKeyLen(4B)][metadataKey][metadataLen(4B)][metadata][messageIv(12B)][messageLen(4B)][message]
                
                // Version identifier - 
                const structVersion = 3; // New format version
                
                // Calculate buffer size
                const totalSize = 1 + // struct version
                                metadataIv.byteLength +
                                4 + // metadata key length
                                exportedMetadataKey.byteLength +
                                4 + // encrypted metadata length
                                encryptedMetadata.byteLength +
                                iv.byteLength +
                                4 + // message length
                                encryptedData.byteLength;
                
                // Create the buffer
                const result = new Uint8Array(totalSize);
                let offset = 0;
                
                // Add struct version
                result[offset++] = structVersion;
                
                // Add metadata IV
                result.set(metadataIv, offset);
                offset += metadataIv.byteLength;
                
                // Add metadata key length (4 bytes, big-endian)
                const metadataKeyLength = exportedMetadataKey.byteLength;
                result[offset++] = (metadataKeyLength >> 24) & 0xFF;
                result[offset++] = (metadataKeyLength >> 16) & 0xFF;
                result[offset++] = (metadataKeyLength >> 8) & 0xFF;
                result[offset++] = metadataKeyLength & 0xFF;
                
                // Add metadata key
                result.set(new Uint8Array(exportedMetadataKey), offset);
                offset += exportedMetadataKey.byteLength;
                
                // Add encrypted metadata length (4 bytes, big-endian)
                const metadataLength = encryptedMetadata.byteLength;
                result[offset++] = (metadataLength >> 24) & 0xFF;
                result[offset++] = (metadataLength >> 16) & 0xFF;
                result[offset++] = (metadataLength >> 8) & 0xFF;
                result[offset++] = metadataLength & 0xFF;
                
                // Add encrypted metadata
                result.set(new Uint8Array(encryptedMetadata), offset);
                offset += encryptedMetadata.byteLength;
                
                // Add message IV
                result.set(iv, offset);
                offset += iv.byteLength;
                
                // Add encrypted message length (4 bytes, big-endian)
                const messageLength = encryptedData.byteLength;
                result[offset++] = (messageLength >> 24) & 0xFF;
                result[offset++] = (messageLength >> 16) & 0xFF;
                result[offset++] = (messageLength >> 8) & 0xFF;
                result[offset++] = messageLength & 0xFF;
                
                // Add encrypted message
                result.set(new Uint8Array(encryptedData), offset);
                
                // Return the result
                return {
                    version: 3, 
                    data: arrayBufferToBase64(result.buffer)
                };
            } catch (error) {
                console.error('AES encryption error:', error);
                throw new Error('Encryption failed: ' + error.message);
            }
        }

        // Helper function to derive a key for metadata encryption
        async function deriveMetadataKey(baseKey, iv) {
            // Export the base key
            const rawKey = await window.crypto.subtle.exportKey('raw', baseKey);
            
            // Create a key derivation context using the IV
            const context = new Uint8Array(rawKey.byteLength + iv.byteLength);
            context.set(new Uint8Array(rawKey), 0);
            context.set(iv, rawKey.byteLength);
            
            // Import as base for derivation
            const baseKeyMaterial = await window.crypto.subtle.importKey(
                'raw',
                context,
                { name: 'HKDF' },
                false,
                ['deriveKey']
            );
            
            // Derive a new key using HKDF
            return window.crypto.subtle.deriveKey(
                {
                    name: 'HKDF',
                    hash: 'SHA-256',
                    salt: iv,
                    info: new Uint8Array([0x01, 0x02, 0x03, 0x04]) // Fixed info
                },
                baseKeyMaterial,
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        async function encryptWithRSA(messageBuffer, keyData) {
            // 1. Generate a random AES key for hybrid encryption
            const aesKey = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true, // Ensure this is extractable
                ['encrypt', 'decrypt']
            );
            
            // 2. Generate a random IV for AES encryption
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // 3. Encrypt the message with AES
            const encryptedMessage = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                aesKey,
                messageBuffer
            );
            
            // 4. Export the AES key to raw format
            const exportedAesKey = await window.crypto.subtle.exportKey('raw', aesKey);
            
            // 5. Import the RSA public key
            let rsaPublicKey;
            if (keyData._publicKey) {
                rsaPublicKey = keyData._publicKey;
            } else {
                const publicKeyBuffer = base64ToArrayBuffer(keyData.publicKey);
                rsaPublicKey = await importRSAPublicKey(publicKeyBuffer, keyData.length || RSA_CONFIG.KEY_SIZE);
            }
            
            // 6. Encrypt the AES key with RSA
            const encryptedAesKey = await window.crypto.subtle.encrypt(
                {
                    name: RSA_CONFIG.ALGORITHM
                },
                rsaPublicKey,
                exportedAesKey
            );
            
            // 7. Create metadata
            const metadata = {
                a: RSA_CONFIG.ALGORITHM + '+' + AES_CONFIG.MODE, // algorithm
                k: keyData.id, // keyId
                t: new Date().toISOString(), // timestamp
                s: keyData.length || RSA_CONFIG.KEY_SIZE // key size
            };

            // Add file metadata if we're encrypting a file
            if (encryptFileData && encryptFileName) {
                metadata.f = {
                    n: encryptFileName,   // filename
                    s: encryptFileData.byteLength  // file size
                };
            }
            
            // 8. Convert metadata to buffer
            const metadataBuffer = new TextEncoder().encode(JSON.stringify(metadata));
            
            // 9. Generate a separate key for metadata encryption
            const metadataEncryptionKey = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true, // Ensure this one is extractable
                ['encrypt', 'decrypt']
            );
            
            // 10. Generate a separate IV for metadata encryption
            const metadataIv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // 11. Encrypt the metadata
            const encryptedMetadata = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: metadataIv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                metadataEncryptionKey,
                metadataBuffer
            );
            
            // 12. Export the metadata encryption key
            const exportedMetadataKey = await window.crypto.subtle.exportKey('raw', metadataEncryptionKey);
            
            // 13. Add random padding (between 1-64 bytes)
            const paddingLength = Math.floor(Math.random() * 64) + 1;
            const padding = window.crypto.getRandomValues(new Uint8Array(paddingLength));
            
            // 14. Combine everything into a single binary package
            const result = new Uint8Array(
                1 + // metadata IV length indicator
                metadataIv.byteLength +
                4 + // metadata key length (4 bytes)
                exportedMetadataKey.byteLength +
                4 + // encrypted metadata length (4 bytes)
                encryptedMetadata.byteLength +
                4 + // RSA encrypted key length (4 bytes)
                encryptedAesKey.byteLength +
                iv.byteLength +
                4 + // encrypted message length (4 bytes)
                encryptedMessage.byteLength +
                1 + // padding length indicator
                padding.byteLength
            );
            
            let offset = 0;
            
            // Add metadata IV length
            result[offset++] = metadataIv.byteLength;
            
            // Add metadata IV
            result.set(metadataIv, offset);
            offset += metadataIv.byteLength;
            
            // Add metadata key length (4 bytes, big-endian)
            const metadataKeyLength = exportedMetadataKey.byteLength;
            result[offset++] = (metadataKeyLength >> 24) & 0xFF;
            result[offset++] = (metadataKeyLength >> 16) & 0xFF;
            result[offset++] = (metadataKeyLength >> 8) & 0xFF;
            result[offset++] = metadataKeyLength & 0xFF;
            
            // Add metadata key
            result.set(new Uint8Array(exportedMetadataKey), offset);
            offset += exportedMetadataKey.byteLength;
            
            // Add encrypted metadata length (4 bytes, big-endian)
            const metadataLength = encryptedMetadata.byteLength;
            result[offset++] = (metadataLength >> 24) & 0xFF;
            result[offset++] = (metadataLength >> 16) & 0xFF;
            result[offset++] = (metadataLength >> 8) & 0xFF;
            result[offset++] = metadataLength & 0xFF;
            
            // Add encrypted metadata
            result.set(new Uint8Array(encryptedMetadata), offset);
            offset += encryptedMetadata.byteLength;
            
            // Add RSA encrypted key length (4 bytes, big-endian)
            const encryptedKeyLength = encryptedAesKey.byteLength;
            result[offset++] = (encryptedKeyLength >> 24) & 0xFF;
            result[offset++] = (encryptedKeyLength >> 16) & 0xFF;
            result[offset++] = (encryptedKeyLength >> 8) & 0xFF;
            result[offset++] = encryptedKeyLength & 0xFF;
            
            // Add RSA encrypted key
            result.set(new Uint8Array(encryptedAesKey), offset);
            offset += encryptedAesKey.byteLength;
            
            // Add AES IV
            result.set(iv, offset);
            offset += iv.byteLength;
            
            // Add encrypted message length (4 bytes, big-endian)
            const messageLength = encryptedMessage.byteLength;
            result[offset++] = (messageLength >> 24) & 0xFF;
            result[offset++] = (messageLength >> 16) & 0xFF;
            result[offset++] = (messageLength >> 8) & 0xFF;
            result[offset++] = messageLength & 0xFF;
            
            // Add encrypted message
            result.set(new Uint8Array(encryptedMessage), offset);
            offset += encryptedMessage.byteLength;
            
            // Add padding length
            result[offset++] = padding.byteLength;
            
            // Add padding
            result.set(padding, offset);
            
            // Return encrypted data with version marker
            return {
                version: 2,
                data: arrayBufferToBase64(result.buffer)
            };
        }
        
        async function encryptWithECC(messageBuffer, keyData) {
            // 1. Generate an ephemeral ECC key pair
            const ephemeralKeyPair = await window.crypto.subtle.generateKey(
                {
                    name: 'ECDH',
                    namedCurve: keyData.curve || ECC_CONFIG.CURVE
                },
                true, // Make sure it's extractable
                ['deriveKey', 'deriveBits']
            );
            
            // 2. Export the ephemeral public key to send with the message
            const ephemeralPublicKey = await window.crypto.subtle.exportKey(
                'spki',
                ephemeralKeyPair.publicKey
            );
            
            // 3. Import the recipient's public key
            let recipientPublicKey;
            if (keyData._publicKey) {
                recipientPublicKey = keyData._publicKey;
            } else {
                const publicKeyBuffer = base64ToArrayBuffer(keyData.publicKey);
                recipientPublicKey = await importECCPublicKey(
                    publicKeyBuffer,
                    keyData.curve || ECC_CONFIG.CURVE
                );
            }
            
            // 4. Generate a random IV for AES encryption
            const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // 5. Derive a shared secret using ECDH
            const sharedSecretBits = await window.crypto.subtle.deriveBits(
                {
                    name: 'ECDH',
                    public: recipientPublicKey
                },
                ephemeralKeyPair.privateKey,
                256 // 256 bits for AES-256
            );
            
            // 6. Convert shared secret to a key
            const derivedKey = await window.crypto.subtle.importKey(
                'raw',
                sharedSecretBits,
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                false,
                ['encrypt']
            );
            
            // 7. Encrypt the message with the derived key
            const encryptedMessage = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                derivedKey,
                messageBuffer
            );
            
            // 8. Create metadata
            const metadata = {
                a: 'ECDH+' + AES_CONFIG.MODE, // algorithm
                k: keyData.id, // keyId
                t: new Date().toISOString(), // timestamp
                c: keyData.curve || ECC_CONFIG.CURVE // curve name
            };

            // Add file metadata if we're encrypting a file
            if (encryptFileData && encryptFileName) {
                metadata.f = {
                    n: encryptFileName,   // filename
                    s: encryptFileData.byteLength  // file size
                };
            }
            
            // 9. Convert metadata to buffer
            const metadataBuffer = new TextEncoder().encode(JSON.stringify(metadata));
            
            // 10. Generate a separate key for metadata encryption
            const metadataEncryptionKey = await window.crypto.subtle.generateKey(
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH
                },
                true, // Ensure this one is extractable
                ['encrypt', 'decrypt']
            );
            
            // 11. Generate a separate IV for metadata encryption
            const metadataIv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
            
            // 12. Encrypt the metadata
            const encryptedMetadata = await window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: metadataIv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                metadataEncryptionKey,
                metadataBuffer
            );
            
            // 13. Export the metadata encryption key
            const exportedMetadataKey = await window.crypto.subtle.exportKey('raw', metadataEncryptionKey);
            
            // 14. Add random padding (between 1-64 bytes)
            const paddingLength = Math.floor(Math.random() * 64) + 1;
            const padding = window.crypto.getRandomValues(new Uint8Array(paddingLength));
            
            // 15. Combine everything into a single binary package
            const result = new Uint8Array(
                1 + // metadata IV length indicator
                metadataIv.byteLength +
                4 + // metadata key length (4 bytes)
                exportedMetadataKey.byteLength +
                4 + // encrypted metadata length (4 bytes)
                encryptedMetadata.byteLength +
                4 + // ephemeral public key length (4 bytes)
                ephemeralPublicKey.byteLength +
                iv.byteLength +
                4 + // encrypted message length (4 bytes)
                encryptedMessage.byteLength +
                1 + // padding length indicator
                padding.byteLength
            );
            
            let offset = 0;
            
            // Add metadata IV length
            result[offset++] = metadataIv.byteLength;
            
            // Add metadata IV
            result.set(metadataIv, offset);
            offset += metadataIv.byteLength;
            
            // Add metadata key length (4 bytes, big-endian)
            const metadataKeyLength = exportedMetadataKey.byteLength;
            result[offset++] = (metadataKeyLength >> 24) & 0xFF;
            result[offset++] = (metadataKeyLength >> 16) & 0xFF;
            result[offset++] = (metadataKeyLength >> 8) & 0xFF;
            result[offset++] = metadataKeyLength & 0xFF;
            
            // Add metadata key
            result.set(new Uint8Array(exportedMetadataKey), offset);
            offset += exportedMetadataKey.byteLength;
            
            // Add encrypted metadata length (4 bytes, big-endian)
            const metadataLength = encryptedMetadata.byteLength;
            result[offset++] = (metadataLength >> 24) & 0xFF;
            result[offset++] = (metadataLength >> 16) & 0xFF;
            result[offset++] = (metadataLength >> 8) & 0xFF;
            result[offset++] = metadataLength & 0xFF;
            
            // Add encrypted metadata
            result.set(new Uint8Array(encryptedMetadata), offset);
            offset += encryptedMetadata.byteLength;
            
            // Add ephemeral public key length (4 bytes, big-endian)
            const ephemeralKeyLength = ephemeralPublicKey.byteLength;
            result[offset++] = (ephemeralKeyLength >> 24) & 0xFF;
            result[offset++] = (ephemeralKeyLength >> 16) & 0xFF;
            result[offset++] = (ephemeralKeyLength >> 8) & 0xFF;
            result[offset++] = ephemeralKeyLength & 0xFF;
            
            // Add ephemeral public key
            result.set(new Uint8Array(ephemeralPublicKey), offset);
            offset += ephemeralPublicKey.byteLength;
            
            // Add AES IV
            result.set(iv, offset);
            offset += iv.byteLength;
            
            // Add encrypted message length (4 bytes, big-endian)
            const messageLength = encryptedMessage.byteLength;
            result[offset++] = (messageLength >> 24) & 0xFF;
            result[offset++] = (messageLength >> 16) & 0xFF;
            result[offset++] = (messageLength >> 8) & 0xFF;
            result[offset++] = messageLength & 0xFF;
            
            // Add encrypted message
            result.set(new Uint8Array(encryptedMessage), offset);
            offset += encryptedMessage.byteLength;
            
            // Add padding length
            result[offset++] = padding.byteLength;
            
            // Add padding
            result.set(padding, offset);
            
            // Return encrypted data with version marker
            return {
                version: 2,
                data: arrayBufferToBase64(result.buffer)
            };
        }
        
        async function decryptMessage() {
            try {
                let encryptionInfo;
                
                const encryptedMessage = document.getElementById('encryptedMessage').value;
                const obfKey = document.getElementById('decryptObfKey').value; // Get OBF Key for decryption

                if (!encryptedMessage) {
                    showStatus('decryptStatus', 'Please enter an encrypted message or add an encrypted file', 'error');
                    return;
                }
                
                // Validate the encrypted message format using the updated validator with OBF Key
                if (!isValidEncryptedMessage(encryptedMessage, obfKey)) { 
                    showStatus('decryptStatus', 'Invalid encrypted message format or OBF Key mismatch', 'error');
                    return;
                }
                
                try {
                    // Parse the encrypted message using the new unified parser with OBF Key
                    encryptionInfo = parseEncryptedMessage(encryptedMessage, obfKey); 
                } catch (error) {
                    showStatus('decryptStatus', 'Invalid encrypted message data: ' + error.message, 'error');
                    return;
                }
                
                const keyId = document.getElementById('decryptionKey').value;
                const keyPassword = document.getElementById('decryptionPassword').value;
                
                if (!keyId) {
                    showStatus('decryptStatus', 'Please select a decryption key', 'error');
                    return;
                }
                
                setLoading(true);
                
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    showStatus('decryptStatus', 'Key not found', 'error');
                    setLoading(false); 
                    return;
                }
                
                let decryptedKeyRef = null;
                let actualKeyData = keyData;
                
                if (keyData.protected) {
                    if (!keyPassword) {
                        showStatus('decryptStatus', 'Password required for this key', 'error');
                        setLoading(false); 
                        return;
                    }
                    
                    try {
                        decryptedKeyRef = await decryptKeyWithPassword(keyData, keyPassword);
                        actualKeyData = safeMemory.retrieve(decryptedKeyRef);
                        if (!actualKeyData) {
                            throw new Error('Failed to retrieve decrypted key from memory.');
                        }
                    } catch (error) {
                        showStatus('decryptStatus', 'Failed to decrypt key: ' + error.message, 'error');
                        setLoading(false);
                        return;
                    }
                }
                
                let decryptResult = await decryptData(encryptionInfo, actualKeyData);
                let decryptedData;
                let metadata;

                if (decryptResult.data) {
                    decryptedData = decryptResult.data;
                    metadata = decryptResult.metadata;
                } else {
                    decryptedData = decryptResult;
                    metadata = null;
                }
                
                if (decryptedKeyRef) {
                    safeMemory.delete(decryptedKeyRef);
                }
                
                // Apply XOR cipher if OBF key was used
                if (obfKey) {
                    decryptedData = xorCipher(decryptedData, obfKey);
                }

                let isFile = false;
                let fileName = null;
                let fileSize = null;
                
                if (!encryptionInfo.version && encryptionInfo.isFile && encryptionInfo.fileName) {
                    isFile = true;
                    fileName = encryptionInfo.fileName;
                    fileSize = encryptionInfo.fileSize || decryptedData.byteLength;
                } 
                else if (metadata && metadata.f) {
                    isFile = true;
                    fileName = metadata.f.n;
                    fileSize = metadata.f.s || decryptedData.byteLength;
                }
                
                if (isFile) {
                    document.getElementById('decryptedOutput').value = `File: ${fileName} (${formatFileSize(fileSize)})`;
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-filename', fileName);
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-binary', 'true');
                    window.decryptedBinaryData = decryptedData;
                } else {
                    const decryptedText = new TextDecoder().decode(decryptedData);
                    document.getElementById('decryptedOutput').value = decryptedText;
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-filename', 'decrypted.txt');
                    document.getElementById('downloadDecryptedBtn').setAttribute('data-binary', 'false');
                    window.decryptedBinaryData = null;
                }
                
                showStatus('decryptStatus', 'Message decrypted successfully', 'success');
            } catch (error) {
                console.error('Decryption error:', error);
                showStatus('decryptStatus', 'Decryption error: ' + error.message, 'error');
            } finally {
                document.getElementById('decryptionPassword').value = '';
                setLoading(false);
            }
        }
        
        async function decryptWithAES(encryptionInfo, keyData) {
            try {
                // Get data buffer
                const fullBuffer = base64ToArrayBuffer(encryptionInfo.data);
                const fullData = new Uint8Array(fullBuffer);
                
                // Parse buffer
                let offset = 0;
                
                // Check structure version (1 byte)
                const structVersion = fullData[offset++];
                
                // We expect version 3
                if (structVersion !== 3) {
                    throw new Error('Unsupported data format version');
                }
                
                // Read metadata IV (12 bytes)
                const metadataIv = fullData.slice(offset, offset + AES_CONFIG.IV_LENGTH);
                offset += AES_CONFIG.IV_LENGTH;
                
                // Read metadata key length (4 bytes)
                const metadataKeyLength = (fullData[offset] << 24) | 
                                        (fullData[offset + 1] << 16) | 
                                        (fullData[offset + 2] << 8) | 
                                        fullData[offset + 3];
                offset += 4;
                
                // Read metadata key
                const metadataKeyData = fullData.slice(offset, offset + metadataKeyLength);
                offset += metadataKeyLength;
                
                // Read encrypted metadata length (4 bytes)
                const metadataLength = (fullData[offset] << 24) | 
                                    (fullData[offset + 1] << 16) | 
                                    (fullData[offset + 2] << 8) | 
                                    fullData[offset + 3];
                offset += 4;
                
                // Read encrypted metadata
                const encryptedMetadata = fullData.slice(offset, offset + metadataLength);
                offset += metadataLength;
                
                // Read message IV (12 bytes)
                const messageIv = fullData.slice(offset, offset + AES_CONFIG.IV_LENGTH);
                offset += AES_CONFIG.IV_LENGTH;
                
                // Read encrypted message length (4 bytes)
                const messageLength = (fullData[offset] << 24) | 
                                (fullData[offset + 1] << 16) | 
                                (fullData[offset + 2] << 8) | 
                                fullData[offset + 3];
                offset += 4;
                
                // Read encrypted message
                const encryptedMessage = fullData.slice(offset, offset + messageLength);
                
                // Import metadata key
                const metadataKey = await window.crypto.subtle.importKey(
                    'raw',
                    metadataKeyData,
                    {
                        name: AES_CONFIG.MODE,
                        length: AES_CONFIG.KEY_LENGTH
                    },
                    false,
                    ['decrypt']
                );
                
                // Decrypt metadata
                const decryptedMetadataBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: metadataIv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    metadataKey,
                    encryptedMetadata
                );
                
                // Parse metadata
                const metadataText = new TextDecoder().decode(decryptedMetadataBuffer);
                const metadata = JSON.parse(metadataText);
                
                // Verify key ID matches
                if (metadata.k !== keyData.id) {
                    throw new Error("Key ID mismatch - wrong key for this message");
                }
                
                // Import the decryption key
                let cryptoKey;
                if (keyData._cryptoKey) {
                    cryptoKey = keyData._cryptoKey;
                } else {
                    const keyBuffer = base64ToArrayBuffer(keyData.key);
                    cryptoKey = await window.crypto.subtle.importKey(
                        'raw',
                        keyBuffer,
                        {
                            name: AES_CONFIG.MODE,
                            length: AES_CONFIG.KEY_LENGTH
                        },
                        false,
                        ['decrypt']
                    );
                }
                
                // Decrypt the message
                return {
                    data: await window.crypto.subtle.decrypt(
                        {
                            name: AES_CONFIG.MODE,
                            iv: messageIv,
                            tagLength: AES_CONFIG.TAG_LENGTH
                        },
                        cryptoKey,
                        encryptedMessage
                    ),
                    metadata: metadata
                };
            } catch (error) {
                console.error('AES Decryption error:', error);
                
                // Provide more detailed error information
                if (error instanceof DOMException) {
                    throw new Error(`Decryption failed: ${error.name} - ${error.message || 'Unknown WebCrypto error'}`);
                } else {
                    throw new Error('Decryption failed: ' + error.message);
                }
            }
        }

        function isValidEncryptedMessage(message, obfKey = '') {
            // This function now ignores obfKey and always looks for the standard delimiters.
            let openDelimiter = SECURE_DELIMITER;
            let closeDelimiter = reverseString(SECURE_DELIMITER);

            // For backward compatibility, check for the old default delimiter as well
            const oldOpenDelimiter = '@!';
            const oldCloseDelimiter = '!@';

            const escapedOpenDelimiter = escapeRegex(openDelimiter);
            const escapedCloseDelimiter = escapeRegex(closeDelimiter);
            const escapedOldOpenDelimiter = escapeRegex(oldOpenDelimiter);
            const escapedOldCloseDelimiter = escapeRegex(oldCloseDelimiter);

            // Pattern that matches either the new secure delimiter or the old one
            const pattern = `^.*?(${escapedOpenDelimiter}|${escapedOldOpenDelimiter})[\\s\\S]+?(${escapedCloseDelimiter}|${escapedOldCloseDelimiter}).*$`;
            const regex = new RegExp(pattern);
            return regex.test(message);
        }

        // Function to create the final encrypted message string
        function createEncryptedMessageString(e, obfKey = '') {
            // This function now ignores obfKey for delimiting. It is only used for the XOR cipher.
            const openDelimiter = SECURE_DELIMITER;
            const closeDelimiter = reverseString(SECURE_DELIMITER);

            // Generate random characters, ensure 32-64 chars
            const randomPrefix = generateRandomString(32 + Math.floor(Math.random() * 33));
            const randomSuffix = generateRandomString(32 + Math.floor(Math.random() * 33));

            // Ensure data has no newlines or whitespace at edges
            const cleanData = typeof e.data === 'string' ? e.data.replace(/[\r\n\s]*(.*?)[\r\n\s]*$/s, '$1') : e.data;

            // Direct concatenation without template literals to avoid any whitespace
            return randomPrefix + openDelimiter + cleanData + closeDelimiter + randomSuffix;
        }

        // Function to parse encrypted message in either format
        function parseEncryptedMessage(encryptedMessage, obfKey = '') {
            // This function now ignores obfKey for delimiting. It is only used for the XOR cipher.
            const openDelimiter = SECURE_DELIMITER;
            const closeDelimiter = reverseString(SECURE_DELIMITER);
            const oldOpenDelimiter = '@!';
            const oldCloseDelimiter = '!@';
            
            const escapedOpenDelimiter = escapeRegex(openDelimiter);
            const escapedCloseDelimiter = escapeRegex(closeDelimiter);
            const escapedOldOpenDelimiter = escapeRegex(oldOpenDelimiter);
            const escapedOldCloseDelimiter = escapeRegex(oldCloseDelimiter);

            // Build a regex that can find content between either the new or old delimiters
            const pattern = `^.*?(${escapedOpenDelimiter}|${escapedOldOpenDelimiter})([\\s\\S]+?)(${escapedCloseDelimiter}|${escapedOldCloseDelimiter}).*$`;
            const regex = new RegExp(pattern);
            const messageMatch = encryptedMessage.match(regex);

            // The actual data is now in the second capture group
            if (!messageMatch || !messageMatch[2]) {
                throw new Error('Invalid encrypted message format. Could not find valid delimiters.');
            }

            const encodedData = messageMatch[2].trim(); 
            return {
                version: 2, 
                data: encodedData
            };
        }

        function updateEncryptionOutput(encryptionResult) {
            return createEncryptedMessageString(encryptionResult);
        }

        function generateRandomString(length = 5) {
            // Safe character set (no problematic characters)
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function determineKeySecurityLevel(keyData) {
            // Start with base security level based on the algorithm and bit length
            let baseLevel = 'low';
            
            // Determine base level by algorithm strength
            if (keyData.type === 'aes' || 
                keyData.type === 'rsa-4096' || 
                keyData.type === 'ecc-p384') {
                baseLevel = 'medium';  // Strong algorithms start at medium
            } else if (keyData.type === 'rsa' || 
                    keyData.type === 'ecc') {
                baseLevel = 'low';     // Less strong algorithms start at low
            }
            
            // Calculate final security level considering multiple factors
            let securityPoints = 0;
            
            // Factor 1: Password protection
            if (keyData.protected) {
                securityPoints += 2;
            }
            
            // Factor 2: Key completeness (for asymmetric keys)
            if (keyData.type !== 'aes') { // Only for asymmetric keys
                if (keyData.hasPublic && keyData.hasPrivate) {
                    securityPoints += 1; // Complete key pair is more secure
                }
            }
            
            // Factor 3: Key expiration
            if (keyData.expiry) {
                securityPoints += 1; // Having an expiration adds security
            }
            
            // Determine final level based on points and base level
            let finalLevel;
            
            if (baseLevel === 'medium') {
                // For stronger algorithms:
                if (securityPoints >= 3) {
                    finalLevel = 'high';
                } else if (securityPoints >= 1) {
                    finalLevel = 'medium';
                } else {
                    finalLevel = 'low';
                }
            } else {
                // For weaker algorithms:
                if (securityPoints >= 4) {
                    finalLevel = 'high';
                } else if (securityPoints >= 2) {
                    finalLevel = 'medium';
                } else {
                    finalLevel = 'low';
                }
            }
            
            return finalLevel;
        }
        
        async function decryptWithRSA(encryptionInfo, keyData) {
            // Check version to support both old and new formats
            if (!encryptionInfo.version || encryptionInfo.version === 1) {
                // Legacy decryption
                const encryptedData = base64ToArrayBuffer(encryptionInfo.data);
                const encryptedAesKey = base64ToArrayBuffer(encryptionInfo.encryptedKey);
                const iv = base64ToArrayBuffer(encryptionInfo.iv);
                
                // Import the RSA private key
                let rsaPrivateKey;
                if (keyData._privateKey) {
                    rsaPrivateKey = keyData._privateKey;
                } else {
                    const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                    rsaPrivateKey = await importRSAPrivateKey(
                        privateKeyBuffer,
                        encryptionInfo.keySize || keyData.length || RSA_CONFIG.KEY_SIZE
                    );
                }
                
                // Decrypt the AES key with RSA
                const aesKeyBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: RSA_CONFIG.ALGORITHM
                    },
                    rsaPrivateKey,
                    encryptedAesKey
                );
                
                // Import the AES key
                const aesKey = await importAESKey(aesKeyBuffer);
                
                // Decrypt the message with the AES key
                return await window.crypto.subtle.decrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: iv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    aesKey,
                    encryptedData
                );
            } else {
                // Version 2+ decryption
                const fullBuffer = base64ToArrayBuffer(encryptionInfo.data);
                const fullData = new Uint8Array(fullBuffer);
                
                let offset = 0;
                
                // Read metadata IV length
                const metadataIvLength = fullData[offset++];
                
                // Read metadata IV
                const metadataIv = fullData.slice(offset, offset + metadataIvLength);
                offset += metadataIvLength;
                
                // Read metadata key length
                const metadataKeyLength = (fullData[offset] << 24) | 
                                        (fullData[offset + 1] << 16) | 
                                        (fullData[offset + 2] << 8) | 
                                        fullData[offset + 3];
                offset += 4;
                
                // Read metadata key
                const metadataKeyData = fullData.slice(offset, offset + metadataKeyLength);
                offset += metadataKeyLength;
                
                // Read encrypted metadata length
                const metadataLength = (fullData[offset] << 24) | 
                                    (fullData[offset + 1] << 16) | 
                                    (fullData[offset + 2] << 8) | 
                                    fullData[offset + 3];
                offset += 4;
                
                // Read encrypted metadata
                const encryptedMetadata = fullData.slice(offset, offset + metadataLength);
                offset += metadataLength;
                
                // Read RSA encrypted key length
                const encryptedKeyLength = (fullData[offset] << 24) | 
                                        (fullData[offset + 1] << 16) | 
                                        (fullData[offset + 2] << 8) | 
                                        fullData[offset + 3];
                offset += 4;
                
                // Read RSA encrypted key
                const encryptedAesKey = fullData.slice(offset, offset + encryptedKeyLength);
                offset += encryptedKeyLength;
                
                // Read AES IV
                const iv = fullData.slice(offset, offset + AES_CONFIG.IV_LENGTH);
                offset += AES_CONFIG.IV_LENGTH;
                
                // Read encrypted message length
                const messageLength = (fullData[offset] << 24) | 
                                    (fullData[offset + 1] << 16) | 
                                    (fullData[offset + 2] << 8) | 
                                    fullData[offset + 3];
                offset += 4;
                
                // Read encrypted message
                const encryptedMessage = fullData.slice(offset, offset + messageLength);
                
                // Import the RSA private key
                let rsaPrivateKey;
                if (keyData._privateKey) {
                    rsaPrivateKey = keyData._privateKey;
                } else {
                    const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                    rsaPrivateKey = await importRSAPrivateKey(
                        privateKeyBuffer,
                        keyData.length || RSA_CONFIG.KEY_SIZE
                    );
                }
                
                // Decrypt the AES key with RSA
                const aesKeyBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: RSA_CONFIG.ALGORITHM
                    },
                    rsaPrivateKey,
                    encryptedAesKey
                );
                
                // Import metadata encryption key
                const metadataKey = await window.crypto.subtle.importKey(
                    'raw',
                    metadataKeyData,
                    {
                        name: AES_CONFIG.MODE,
                        length: metadataKeyLength * 8
                    },
                    false,
                    ['decrypt']
                );
                
                // Decrypt metadata
                const decryptedMetadataBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: metadataIv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    metadataKey,
                    encryptedMetadata
                );
                
                // Parse metadata
                const metadataText = new TextDecoder().decode(decryptedMetadataBuffer);
                const metadata = JSON.parse(metadataText);
                
                // Verify key ID matches
                if (metadata.k !== keyData.id) {
                    throw new Error("Key ID mismatch - wrong key for this message");
                }
                
                // Import the AES key
                const aesKey = await importAESKey(aesKeyBuffer);
                
                // Decrypt the message with the AES key
                return {
                    data: await window.crypto.subtle.decrypt(
                        {
                            name: AES_CONFIG.MODE,
                            iv: iv,
                            tagLength: AES_CONFIG.TAG_LENGTH
                        },
                        aesKey,
                        encryptedMessage
                    ),
                    metadata: metadata
                };
            }
        }

        async function decryptWithECC(encryptionInfo, keyData) {
            // Check version to support both old and new formats
            if (!encryptionInfo.version || encryptionInfo.version === 1) {
                // Legacy decryption
                const encryptedData = base64ToArrayBuffer(encryptionInfo.data);
                const ephemeralPublicKeyBuffer = base64ToArrayBuffer(encryptionInfo.ephemeralPublicKey);
                const iv = base64ToArrayBuffer(encryptionInfo.iv);
                
                // Import the ephemeral public key
                const ephemeralPublicKey = await importECCPublicKey(
                    ephemeralPublicKeyBuffer,
                    encryptionInfo.curve || ECC_CONFIG.CURVE
                );
                
                // Import the private key
                let privateKey;
                if (keyData._privateKey) {
                    privateKey = keyData._privateKey;
                } else {
                    const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                    privateKey = await importECCPrivateKey(
                        privateKeyBuffer,
                        encryptionInfo.curve || ECC_CONFIG.CURVE
                    );
                }
                
                // Derive the shared secret using ECDH
                const derivedKey = await window.crypto.subtle.deriveKey(
                    {
                        name: 'ECDH',
                        public: ephemeralPublicKey
                    },
                    privateKey,
                    {
                        name: AES_CONFIG.MODE,
                        length: AES_CONFIG.KEY_LENGTH
                    },
                    false,
                    ['decrypt']
                );
                
                // Decrypt the message with the derived key
                return await window.crypto.subtle.decrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: iv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    derivedKey,
                    encryptedData
                );
            } else {
                // Version 2+ decryption
                const fullBuffer = base64ToArrayBuffer(encryptionInfo.data);
                const fullData = new Uint8Array(fullBuffer);
                
                let offset = 0;
                
                // Read metadata IV length
                const metadataIvLength = fullData[offset++];
                
                // Read metadata IV
                const metadataIv = fullData.slice(offset, offset + metadataIvLength);
                offset += metadataIvLength;
                
                // Read metadata key length
                const metadataKeyLength = (fullData[offset] << 24) | 
                                        (fullData[offset + 1] << 16) | 
                                        (fullData[offset + 2] << 8) | 
                                        fullData[offset + 3];
                offset += 4;  // FIXED: Changed "a4" to "4"
                
                // Read metadata key
                const metadataKeyData = fullData.slice(offset, offset + metadataKeyLength);
                offset += metadataKeyLength;
                
                // Read encrypted metadata length
                const metadataLength = (fullData[offset] << 24) | 
                                    (fullData[offset + 1] << 16) | 
                                    (fullData[offset + 2] << 8) | 
                                    fullData[offset + 3];
                offset += 4;
                
                // Read encrypted metadata
                const encryptedMetadata = fullData.slice(offset, offset + metadataLength);
                offset += metadataLength;
                
                // Read ephemeral public key length
                const ephemeralKeyLength = (fullData[offset] << 24) | 
                                        (fullData[offset + 1] << 16) | 
                                        (fullData[offset + 2] << 8) | 
                                        fullData[offset + 3];
                offset += 4;
                
                // Read ephemeral public key
                const ephemeralPublicKeyData = fullData.slice(offset, offset + ephemeralKeyLength);
                offset += ephemeralKeyLength;
                
                // Read AES IV
                const iv = fullData.slice(offset, offset + AES_CONFIG.IV_LENGTH);
                offset += AES_CONFIG.IV_LENGTH;
                
                // Read encrypted message length
                const messageLength = (fullData[offset] << 24) | 
                                    (fullData[offset + 1] << 16) | 
                                    (fullData[offset + 2] << 8) | 
                                    fullData[offset + 3];
                offset += 4;
                
                // Read encrypted message
                const encryptedMessage = fullData.slice(offset, offset + messageLength);
                
                // Import the ephemeral public key
                const ephemeralPublicKey = await importECCPublicKey(
                    ephemeralPublicKeyData,
                    keyData.curve || ECC_CONFIG.CURVE
                );
                
                // Import the private key
                let privateKey;
                if (keyData._privateKey) {
                    privateKey = keyData._privateKey;
                } else {
                    const privateKeyBuffer = base64ToArrayBuffer(keyData.privateKey);
                    privateKey = await importECCPrivateKey(
                        privateKeyBuffer,
                        keyData.curve || ECC_CONFIG.CURVE
                    );
                }
                
                // Derive the shared secret using ECDH
                const sharedSecretBits = await window.crypto.subtle.deriveBits(
                    {
                        name: 'ECDH',
                        public: ephemeralPublicKey
                    },
                    privateKey,
                    256 // 256 bits for AES-256
                );
                
                // Import the AES key from the shared secret
                const derivedKey = await window.crypto.subtle.importKey(
                    'raw',
                    sharedSecretBits,
                    {
                        name: AES_CONFIG.MODE,
                        length: AES_CONFIG.KEY_LENGTH
                    },
                    false,
                    ['decrypt']
                );
                
                // Import metadata encryption key
                const metadataKey = await window.crypto.subtle.importKey(
                    'raw',
                    metadataKeyData,
                    {
                        name: AES_CONFIG.MODE,
                        length: metadataKeyLength * 8
                    },
                    false,
                    ['decrypt']
                );
                
                // Decrypt metadata
                const decryptedMetadataBuffer = await window.crypto.subtle.decrypt(
                    {
                        name: AES_CONFIG.MODE,
                        iv: metadataIv,
                        tagLength: AES_CONFIG.TAG_LENGTH
                    },
                    metadataKey,
                    encryptedMetadata
                );
                
                // Parse metadata
                const metadataText = new TextDecoder().decode(decryptedMetadataBuffer);
                const metadata = JSON.parse(metadataText);
                
                // Verify key ID matches
                if (metadata.k !== keyData.id) {
                    throw new Error("Key ID mismatch - wrong key for this message");
                }
                
                // Decrypt the message with the derived key
                return {
                    data: await window.crypto.subtle.decrypt(
                        {
                            name: AES_CONFIG.MODE,
                            iv: iv,
                            tagLength: AES_CONFIG.TAG_LENGTH
                        },
                        derivedKey,
                        encryptedMessage
                    ),
                    metadata: metadata
                };
            }
        }

        function reverseString(str) {
            if (typeof str !== 'string') return '';
            return str.split('').reverse().join('');
        }

        // File download functions
        function downloadEncryptedFile() {
            const encryptedOutput = document.getElementById('encryptedOutput').value;
            if (!encryptedOutput) {
                showStatus('encryptStatus', 'No encrypted data to download', 'error');
                return;
            }
            
            const filename = document.getElementById('downloadEncryptedBtn').getAttribute('data-filename') || generateRandomFileName(6) + '.lmn';
            
            const blob = new Blob([encryptedOutput], { type: 'application/octet-stream' });
            downloadBlob(blob, filename);
            
            showStatus('encryptStatus', `File "${filename}" downloaded successfully`, 'success');
        }

        function downloadDecryptedFile() {
            if (window.decryptedBinaryData) {
                // Binary file
                const filename = document.getElementById('downloadDecryptedBtn').getAttribute('data-filename') || 'decrypted_file';
                const blob = new Blob([window.decryptedBinaryData], { type: 'application/octet-stream' });
                downloadBlob(blob, filename);
            } else {
                // Text file
                const decryptedOutput = document.getElementById('decryptedOutput').value;
                if (!decryptedOutput) {
                    showStatus('decryptStatus', 'No decrypted data to download', 'error');
                    return;
                }
                
                const filename = document.getElementById('downloadDecryptedBtn').getAttribute('data-filename') || 'decrypted.txt';
                // Also change MIME type here for consistency
                const blob = new Blob([decryptedOutput], { type: 'application/octet-stream' });
                downloadBlob(blob, filename);
            }
            
            showStatus('decryptStatus', 'File downloaded successfully', 'success');
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Key Import/Export Functions
        function importKey() {
            const keyFileInput = createKeyFileInput();
            keyFileInput.click();
        }
        
        async function exportKey(keyId, exportPrivate = false) {
            try {
                const keyData = keys.find(k => k.id === keyId);
                if (!keyData) {
                    alert('Key not found');
                    return;
                }
                
                // Check if trying to export a private key
                const isAsymmetric = keyData.type === 'rsa' || keyData.type === 'rsa-4096' || 
                                    keyData.type === 'ecc' || keyData.type === 'ecc-p384';
                
                let exportData = keyData;
                let fileExtension = '.lim'; // Default for public or symmetric keys
                
                if (isAsymmetric && exportPrivate) {
                    // If exporting private key part, prompt for password using the modal
                    let exportPassword = '';
                    try {
                        exportPassword = await showPasswordModal(
                            "Secure Your Private Key", 
                            "Please enter a password to protect this private key:", 
                            true // Show password strength meter
                        );
                    } catch (error) {
                        // User cancelled the password entry
                        return;
                    }
                    
                    // If empty password, show warning confirmation
                    if (!exportPassword) {
                        if (!confirm("Warning: Exporting a private key without password protection is a security risk. Continue anyway?")) {
                            return;
                        }
                    }
                    
                    // Prepare private key export - clone the key data
                    exportData = {
                        id: keyData.id,
                        name: keyData.name,
                        type: keyData.type,
                        created: keyData.created,
                        expiry: keyData.expiry,
                        privateKey: keyData.privateKey,
                        protected: keyData.protected,
                        salt: keyData.salt,
                        iv: keyData.iv,
                        algorithm: keyData.algorithm,
                        hasPrivate: true,
                        hasPublic: false,
                        pairedKeyId: keyData.id,
                        publicKeyHash: keyData.publicKeyHash
                    };
                    
                    // Add length or curve specific to RSA or ECC
                    if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                        exportData.length = keyData.length;
                    } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                        exportData.curve = keyData.curve;
                    }
                    
                    // If a new password was provided, encrypt the private key with it
                    if (exportPassword) {
                        // Decrypt with original password if needed
                        if (keyData.protected) {
                            try {
                                // Get current password from user
                                const currentPassword = await showPasswordModal(
                                    "Enter Current Password",
                                    "Enter the current key password to continue:",
                                    false
                                );
                                
                                const decryptedKeyRef = await decryptKeyWithPassword(keyData, currentPassword);
                                const decryptedKey = safeMemory.retrieve(decryptedKeyRef, true);
                                exportData.privateKey = decryptedKey.privateKey;
                                exportData.protected = false; // Reset protection status
                            } catch (error) {
                                showStatus('keyStatus', 'Export cancelled: ' + error.message, 'error');
                                return;
                            }
                        }
                        
                        // Encrypt with new password
                        await encryptKeyWithPassword(exportData, exportPassword);
                    }
                    
                    fileExtension = '.lem'; // Private key extension
                } else if (isAsymmetric && !exportPrivate) {
                    // Exporting public key - remove private key data
                    exportData = {
                        id: keyData.id,
                        name: keyData.name,
                        type: keyData.type,
                        created: keyData.created,
                        expiry: keyData.expiry,
                        publicKey: keyData.publicKey,
                        algorithm: keyData.algorithm,
                        hasPublic: true,
                        hasPrivate: false,
                        pairedKeyId: keyData.id,
                        publicKeyHash: keyData.publicKeyHash
                    };
                    
                    // Add length or curve specific to RSA or ECC
                    if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                        exportData.length = keyData.length;
                    } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                        exportData.curve = keyData.curve;
                    }
                }
                
                // Convert key data to JSON and then to base64
                const jsonText = JSON.stringify(exportData);
                const exportText = btoa(jsonText);
                
                // Create a download with the appropriate extension
                const blob = new Blob([exportText], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${keyData.name.replace(/[^a-z0-9]/gi, '_')}${fileExtension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                const keyTypeText = exportPrivate ? "private key" : (isAsymmetric ? "public key" : "key");
                showStatus('keyStatus', `Key "${keyData.name}" ${keyTypeText} exported as ${fileExtension} file`, 'success');
            } catch (error) {
                console.error('Export error:', error);
                showStatus('keyStatus', 'Export error: ' + error.message, 'error');
            }
        }

        // Export private key function
        async function exportPrivateKey(keyId) {
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) {
                alert('Key not found');
                return;
            }
            
            // Check if this key has a private part
            if (!keyData.hasPrivate) {
                showStatus('keyStatus', 'This key does not have a private key component to export', 'error');
                return;
            }
            
            const confirmExport = confirm(
                "WARNING: Exporting a private key is a security risk. " +
                "Only export private keys if you absolutely need to use them on another device. " +
                "Do you want to continue?"
            );
            
            if (confirmExport) {
                await exportKey(keyId, true);
            }
        }

        function createKeyFileInput() {
            // Check if it already exists
            let keyFileInput = document.getElementById('keyFileInput');
            
            if (!keyFileInput) {
                keyFileInput = document.createElement('input');
                keyFileInput.type = 'file';
                keyFileInput.id = 'keyFileInput';
                keyFileInput.accept = '.lim,.lem';
                keyFileInput.style.display = 'none';
                document.body.appendChild(keyFileInput);
                
                // Add event listener
                keyFileInput.addEventListener('change', handleKeyFileSelect);
            }
            
            return keyFileInput;
        }

        async function handleKeyFileSelect(event) {
            try {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                setLoading(true);
                const file = files[0];
                
                // Check file extension
                const isPrivateKey = file.name.toLowerCase().endsWith('.lem');
                const isPublicKey = file.name.toLowerCase().endsWith('.lim');
                
                // Read the file content
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const importText = e.target.result;
                        let keyData;
                        
                        try {
                            const jsonText = atob(importText);
                            keyData = JSON.parse(jsonText);
                        } catch (error) {
                            throw new Error('Invalid key file format');
                        }
                        
                        // Validate the key data
                        if (!keyData.id || !keyData.name || !keyData.type || !keyData.created) {
                            throw new Error('Missing required key properties');
                        }
                        
                        // Validate key name
                        if (!validator.isValidKeyName(keyData.name)) {
                            throw new Error('Invalid key name format');
                        }
                        
                        // Set hasPublic/hasPrivate flags if not already present (for backwards compatibility)
                        if (keyData.type === 'aes') {
                            // Symmetric keys always have both
                            keyData.hasPublic = true;
                            keyData.hasPrivate = true;
                        } else {
                            // For asymmetric keys, check what's in the file
                            keyData.hasPublic = !!keyData.publicKey;
                            keyData.hasPrivate = !!keyData.privateKey;
                            
                            // If extension is .lem but file doesn't have privateKey, warn
                            if (isPrivateKey && !keyData.hasPrivate) {
                                throw new Error('This .lem file does not contain a private key');
                            }
                            
                            // If extension is .lim but file doesn't have publicKey, warn
                            if (isPublicKey && !keyData.hasPublic) {
                                throw new Error('This .lim file does not contain a public key');
                            }
                        }
                        
                        // If importing a private key that's password-protected, prompt for password using the modal
                        if (keyData.hasPrivate && keyData.protected) {
                            let importPassword = '';
                            try {
                                importPassword = await showPasswordModal(
                                    "Protected Private Key",
                                    "This private key is password-protected. Please enter the password to import it:",
                                    false
                                );
                            } catch (error) {
                                throw new Error('Password is required to import this protected private key');
                            }
                            
                            if (!importPassword) {
                                throw new Error('Password is required to import this protected private key');
                            }
                            
                            // Store the original password for later use
                            keyData._importPassword = importPassword;
                        }
                        
                        // Check if a key with this ID already exists
                        const existingKeyIndex = keys.findIndex(k => k.id === keyData.id);
                
                        // Check if this might be a private key for an existing public key or vice versa
                        let isPotentialPair = false;
                        let pairIndex = -1;
                        
                        if (existingKeyIndex >= 0) {
                            const existingKey = keys[existingKeyIndex];
                            
                            // If importing private key and existing key is public-only
                            if (keyData.hasPrivate && !existingKey.hasPrivate && existingKey.hasPublic) {
                                isPotentialPair = true;
                                pairIndex = existingKeyIndex;
                            }
                            // If importing public key and existing key is private-only
                            else if (keyData.hasPublic && !existingKey.hasPublic && existingKey.hasPrivate) {
                                isPotentialPair = true;
                                pairIndex = existingKeyIndex;
                            }
                        } else {
                            // Check if there's a potential pair by public key hash
                            if (keyData.publicKeyHash) {
                                pairIndex = keys.findIndex(k => 
                                    k.publicKeyHash === keyData.publicKeyHash && 
                                    k.type === keyData.type &&
                                    ((k.hasPrivate && !k.hasPublic && keyData.hasPublic) || 
                                    (k.hasPublic && !k.hasPrivate && keyData.hasPrivate))
                                );
                                
                                if (pairIndex >= 0) {
                                    isPotentialPair = true;
                                }
                            }
                        }
                        
                        if (isPotentialPair && pairIndex >= 0) {
                            // found a potential pair - ask if user wants to merge them
                            const mergePair = confirm(
                                `This appears to be the ${keyData.hasPrivate ? 'private' : 'public'} key part of an existing key. ` +
                                `Would you like to merge them into a complete key pair?`
                            );
                            
                            if (mergePair) {
                                // Merge the keys
                                const existingKey = keys[pairIndex];
                                
                                // If importing private key, add it to the existing key
                                if (keyData.hasPrivate && !existingKey.hasPrivate) {
                                    existingKey.privateKey = keyData.privateKey;
                                    existingKey.hasPrivate = true;
                                    
                                    // Copy protection settings if the private key is protected
                                    if (keyData.protected) {
                                        existingKey.protected = true;
                                        existingKey.salt = keyData.salt;
                                        existingKey.iv = keyData.iv;
                                    }
                                }
                                
                                // If importing public key, add it to the existing key
                                if (keyData.hasPublic && !existingKey.hasPublic) {
                                    existingKey.publicKey = keyData.publicKey;
                                    existingKey.hasPublic = true;
                                    
                                    // Update public key hash if needed
                                    if (keyData.publicKeyHash) {
                                        existingKey.publicKeyHash = keyData.publicKeyHash;
                                    }
                                }
                                
                                // Set paired ID for both to be the same
                                existingKey.pairedKeyId = existingKey.id;
                                
                                await saveKeys();
                                showStatus('keyStatus', `Key "${existingKey.name}" updated with ${keyData.hasPrivate ? 'private' : 'public'} key part. Security level: ${determineKeySecurityLevel(existingKey).toUpperCase()}`, 'success');
                            } else {
                                // User chose not to merge, import as separate key
                                keyData.id = crypto.randomUUID(); // Generate new ID to avoid conflict
                                keys.push(keyData);
                                await saveKeys();
                                showStatus('keyStatus', `Key "${keyData.name}" imported as separate key`, 'success');
                            }
                        } else if (existingKeyIndex >= 0) {
                            // A key with this ID exists but isn't a potential pair
                            const overwrite = confirm(`A key with name "${keyData.name}" already exists. Overwrite?`);
                            if (overwrite) {
                                keys[existingKeyIndex] = keyData;
                            } else {
                                // Generate a new ID for the key
                                keyData.id = crypto.randomUUID();
                                keys.push(keyData);
                            }
                            await saveKeys();
                            showStatus('keyStatus', `Key "${keyData.name}" imported successfully`, 'success');
                        } else {
                            // No existing key with this ID
                            keys.push(keyData);
                            await saveKeys();
                            
                            // Show appropriate message based on key type
                            if (keyData.type === 'aes') {
                                showStatus('keyStatus', `Symmetric key "${keyData.name}" imported successfully`, 'success');
                            } else if (keyData.hasPrivate && keyData.hasPublic) {
                                showStatus('keyStatus', `Complete asymmetric key pair "${keyData.name}" imported successfully`, 'success');
                            } else if (keyData.hasPrivate) {
                                showStatus('keyStatus', `Private key "${keyData.name}" imported successfully`, 'success');
                            } else {
                                showStatus('keyStatus', `Public key "${keyData.name}" imported successfully`, 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        showStatus('keyStatus', 'Import error: ' + error.message, 'error');
                    } finally {
                        setLoading(false);
                        // Reset the input so the same file can be selected again
                        document.getElementById('keyFileInput').value = '';
                    }
                };
                
                reader.onerror = function() {
                    setLoading(false);
                    showStatus('keyStatus', 'Error reading the key file', 'error');
                    document.getElementById('keyFileInput').value = '';
                };
                
                reader.readAsText(file);
                
            } catch (error) {
                console.error('Import error:', error);
                showStatus('keyStatus', 'Import error: ' + error.message, 'error');
                setLoading(false);
                document.getElementById('keyFileInput').value = '';
            }
        }
        
        async function exportAllKeys() {
            try {
                if (keys.length === 0) {
                    showStatus('keyStatus', 'No keys available to export', 'warning');
                    return;
                }
                
                // Ask for a password to protect the export using the modal
                let password = '';
                try {
                    password = await showPasswordModal(
                        "Secure Your Key Backup",
                        "Please enter a password to protect your key backup. This is highly recommended for security.",
                        true // Show password strength meter
                    );
                } catch (error) {
                    // User cancelled password entry
                    return;
                }
                
                // Create a data blob
                let exportData;
                
                if (password) {
                    // Encrypt the keys for additional security
                    const keysJson = JSON.stringify(keys);
                    const keysBuffer = new TextEncoder().encode(keysJson);
                    
                    // Generate salt and derive key
                    const salt = window.crypto.getRandomValues(new Uint8Array(16));
                    const derivedKey = await deriveKeyFromPassword(password, salt);
                    
                    // Generate IV
                    const iv = window.crypto.getRandomValues(new Uint8Array(AES_CONFIG.IV_LENGTH));
                    
                    // Encrypt keys
                    const encryptedKeys = await encryptWithDerivedKey(derivedKey, keysBuffer, iv);
                    
                    // Create protected export format
                    exportData = JSON.stringify({
                        format: 'LemonadeProtectedBackup',
                        salt: arrayBufferToBase64(salt),
                        iv: arrayBufferToBase64(iv),
                        data: arrayBufferToBase64(encryptedKeys)
                    });
                } else {
                    // Unprotected export - show warning
                    const confirmUnprotected = confirm("WARNING: Exporting keys without a password is not secure. Anyone with access to this file will be able to use your keys. Continue anyway?");
                    if (!confirmUnprotected) return;
                    
                    exportData = JSON.stringify(keys);
                }
                
                // Create the download link
                const blob = new Blob([exportData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Lemonade-state.state';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('keyStatus', 'Application state exported successfully', 'success');
            } catch (error) {
                console.error('Export error:', error);
                showStatus('keyStatus', 'Export error: ' + error.message, 'error');
            }
        }

        function createStateFileInput() {
            // Check if it already exists
            let stateFileInput = document.getElementById('stateFileInput');
            
            if (!stateFileInput) {
                stateFileInput = document.createElement('input');
                stateFileInput.type = 'file';
                stateFileInput.id = 'stateFileInput';
                stateFileInput.accept = '.state,application/octet-stream';  // Accept both .state extension and octet-stream type
                stateFileInput.style.display = 'none';
                document.body.appendChild(stateFileInput);
                
                // Add event listener
                stateFileInput.addEventListener('change', handleStateFileSelect);
            }
            
            return stateFileInput;
        }

        async function handleStateFileSelect(event) {
            try {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                setLoading(true);
                const file = files[0];
                
                // Read the file content
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    try {
                        const importText = e.target.result;
                        let importData;
                        
                        try {
                            importData = JSON.parse(importText);
                        } catch (error) {
                            throw new Error('Invalid state file format');
                        }
                        
                        // Check if it's a protected backup
                        if (importData.format === 'LemonadeProtectedBackup') {
                            let password = '';
                            try {
                                password = await showPasswordModal(
                                    "Protected State File",
                                    "This state file is password-protected. Please enter the password to import:",
                                    false
                                );
                            } catch (error) {
                                throw new Error('Password is required to import this protected state file');
                            }
                            
                            if (!password) {
                                throw new Error('Password is required to import this protected state file');
                            }
                            
                            // Extract the salt, IV, and encrypted data
                            const salt = base64ToArrayBuffer(importData.salt);
                            const iv = base64ToArrayBuffer(importData.iv);
                            const encryptedData = base64ToArrayBuffer(importData.data);
                            
                            // Derive the key from the password
                            const derivedKey = await deriveKeyFromPassword(password, salt);
                            
                            // Decrypt the data
                            const decryptedData = await decryptWithDerivedKey(derivedKey, encryptedData, iv);
                            
                            // Parse the decrypted data
                            const decryptedText = new TextDecoder().decode(decryptedData);
                            importData = JSON.parse(decryptedText);
                        }
                        
                        // Validate the imported data
                        if (!Array.isArray(importData)) {
                            throw new Error('Invalid state data format');
                        }
                        
                        // Confirmation before overwriting existing keys
                        const confirmImport = confirm(`This will import ${importData.length} keys into your application. Continue?`);
                        if (!confirmImport) return;
                        
                        // Import the keys
                        keys = importData;
                        await saveKeys();
                        
                        showStatus('keyStatus', `Application state with ${importData.length} keys imported successfully`, 'success');
                    } catch (error) {
                        console.error('State import error:', error);
                        showStatus('keyStatus', 'State import error: ' + error.message, 'error');
                    } finally {
                        setLoading(false);
                        // Reset the input so the same file can be selected again
                        document.getElementById('stateFileInput').value = '';
                    }
                };
                
                reader.onerror = function() {
                    setLoading(false);
                    showStatus('keyStatus', 'Error reading the state file', 'error');
                    document.getElementById('stateFileInput').value = '';
                };
                
                reader.readAsText(file);
                
            } catch (error) {
                console.error('State import error:', error);
                showStatus('keyStatus', 'State import error: ' + error.message, 'error');
                setLoading(false);
                document.getElementById('stateFileInput').value = '';
            }
        }

        function importState() {
            const stateFileInput = createStateFileInput();
            stateFileInput.click();
        }
        
        async function secureClipboardCopy(text) {
            // Try the modern Clipboard API with secure context
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (clipboardError) {
                console.log('Modern clipboard API failed:', clipboardError);
                return false;
            }
        }
        
        function deleteKey(keyId) {
            const keyData = keys.find(k => k.id === keyId);
            if (!keyData) {
                alert('Key not found');
                return;
            }
            
            const confirm = window.confirm(`Are you sure you want to delete the key "${keyData.name}"? This action cannot be undone.`);
            if (confirm) {
                keys = keys.filter(k => k.id !== keyId);
                saveKeys();
                showStatus('keyStatus', `Key "${keyData.name}" deleted successfully`, 'success');
            }
        }
        
        // XOR cipher for an additional layer of obfuscation
        function xorCipher(data, key) {
            if (!key) return data;
            const keyBytes = new TextEncoder().encode(key);
            const dataBytes = new Uint8Array(data);
            const output = new Uint8Array(data.byteLength);
            for (let i = 0; i < dataBytes.length; i++) {
                output[i] = dataBytes[i] ^ keyBytes[i % keyBytes.length];
            }
            return output.buffer;
        }

        // Utility Functions
        function showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            statusElement.textContent = validator.sanitizeHTML(message);
            statusElement.className = `status ${type}`;
            
            // Auto-hide status after 10 seconds
            setTimeout(() => {
                if (statusElement.textContent === validator.sanitizeHTML(message)) {
                    statusElement.className = 'status';
                }
            }, 10000);
        }

        // Password Modal Functionality
        let passwordModalCallback = null;
        let passwordModalResolve = null;
        let passwordModalReject = null;

        // Function to show password modal and return a promise with the result
        function showPasswordModal(title, message, showStrength = false) {
            return new Promise((resolve, reject) => {
                const modal = document.getElementById('passwordModal');
                const modalTitle = document.getElementById('passwordModalTitle');
                const modalMessage = document.getElementById('passwordModalMessage');
                const passwordInput = document.getElementById('passwordModalInput');
                const passwordStrength = document.getElementById('passwordModalStrength');
                const passwordFeedback = document.getElementById('passwordModalFeedback');
                
                // Set modal content
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                passwordInput.value = '';
                
                // Reset password strength indicator - add this to ensure it starts fresh
                passwordStrength.className = 'password-strength';
                passwordFeedback.textContent = '';
                
                // Show/hide password strength meter
                passwordStrength.style.display = showStrength ? 'block' : 'none';
                passwordFeedback.style.display = showStrength ? 'block' : 'none';
                
                // Store the resolve/reject functions
                passwordModalResolve = resolve;
                passwordModalReject = reject;
                
                // Show the modal
                modal.style.display = 'flex';
                
                // Focus the input
                setTimeout(() => {
                    passwordInput.focus();
                }, 100);
            });
        }

        // confirmPasswordModal function
        function confirmPasswordModal() {
            const passwordInput = document.getElementById('passwordModalInput');
            const password = passwordInput.value;
            
            // Get references to strength elements
            const passwordStrength = document.getElementById('passwordModalStrength');
            const passwordFeedback = document.getElementById('passwordModalFeedback');
            
            // Reset strength indicator and feedback
            passwordStrength.className = 'password-strength';
            passwordFeedback.textContent = '';
            
            // Hide the modal
            document.getElementById('passwordModal').style.display = 'none';
            
            // Resolve the promise with the password
            if (passwordModalResolve) {
                passwordModalResolve(password);
                passwordModalResolve = null;
                passwordModalReject = null;
            }
        }

        // cancelPasswordModal function
        function cancelPasswordModal() {
            // Get references to password input and strength elements
            const passwordInput = document.getElementById('passwordModalInput');
            const passwordStrength = document.getElementById('passwordModalStrength');
            const passwordFeedback = document.getElementById('passwordModalFeedback');
            
            // Reset input, strength indicator and feedback
            passwordInput.value = '';
            passwordStrength.className = 'password-strength';
            passwordFeedback.textContent = '';
            
            // Hide the modal
            document.getElementById('passwordModal').style.display = 'none';
            
            // Reject the promise
            if (passwordModalReject) {
                passwordModalReject(new Error('Password entry cancelled'));
                passwordModalResolve = null;
                passwordModalReject = null;
            }
        }

        // Handle password strength in the modal
        function updateModalPasswordStrength() {
            const password = document.getElementById('passwordModalInput').value;
            const strength = validator.measurePasswordStrength(password);
            
            const strengthElement = document.getElementById('passwordModalStrength');
            const feedbackElement = document.getElementById('passwordModalFeedback');
            
            // Clear existing classes
            strengthElement.className = 'password-strength';
            
            if (password) {
                // Add class based on strength
                strengthElement.classList.add(strength.strengthCategory);
                
                // Update feedback
                feedbackElement.textContent = strength.feedback;
            } else {
                feedbackElement.textContent = '';
            }
        }
        
        async function copyToClipboard(sourceElementId, statusElementId) {
            const text = document.getElementById(sourceElementId).value;
            if (!text) {
                showStatus(statusElementId, 'Nothing to copy', 'error');
                return;
            }
            
            const success = await secureClipboardCopy(text);
            
            if (success) {
                showStatus(statusElementId, 'Copied to clipboard', 'success');
                
                // If configured, schedule clipboard clearing
                if (appSettings.clearClipboard) {
                    scheduleClipboardClear();
                }
            } else {
                showStatus(statusElementId, 'Unable to copy automatically. Please select the text and press Ctrl+C (or âŒ˜+C) to copy manually.', 'warning');
                
                // Select the text in the original element for easier manual copying
                const element = document.getElementById(sourceElementId);
                element.focus();
                element.select();
            }
        }

        function toggleDarkMode() {
            const darkModeEnabled = document.getElementById('darkMode').checked;
            if (darkModeEnabled) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            localStorage.setItem('LemonadeDarkMode', darkModeEnabled);
        }
        
        // Crypto Helper Functions
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        function base64ToArrayBuffer(base64) {
            try {
                // Try regular base64 decoding
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                console.error('Base64 decoding error:', error);
                throw new Error('Invalid base64 data: ' + error.message);
            }
        }

        // Main function to handle encryption for all types
        async function encryptData(messageBuffer, keyData) {
            if (keyData.type === 'aes') {
                return await encryptWithAES(messageBuffer, keyData);
            } else if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                return await encryptWithRSA(messageBuffer, keyData);
            } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                return await encryptWithECC(messageBuffer, keyData);
            } else {
                throw new Error('Unsupported key type');
            }
        }

        // Main function to handle decryption for all types
        async function decryptData(encryptionInfo, keyData) {
            // For V2 format, determine algorithm based on key type
            if (encryptionInfo.version === 2) {
                if (keyData.type === 'aes') {
                    return await decryptWithAES(encryptionInfo, keyData);
                } else if (keyData.type === 'rsa' || keyData.type === 'rsa-4096') {
                    return await decryptWithRSA(encryptionInfo, keyData);
                } else if (keyData.type === 'ecc' || keyData.type === 'ecc-p384') {
                    return await decryptWithECC(encryptionInfo, keyData);
                }
            }
            
            // For V1 format or other cases, use the algorithm field
            if (encryptionInfo.algorithm === AES_CONFIG.MODE) {
                return await decryptWithAES(encryptionInfo, keyData);
            } else if (encryptionInfo.algorithm === RSA_CONFIG.ALGORITHM + '+' + AES_CONFIG.MODE || 
                    encryptionInfo.algorithm === 'RSA-OAEP+AES-GCM') {
                return await decryptWithRSA(encryptionInfo, keyData);
            } else if (encryptionInfo.algorithm === 'ECDH+' + AES_CONFIG.MODE || 
                    encryptionInfo.algorithm === 'ECDH+AES-GCM') {
                return await decryptWithECC(encryptionInfo, keyData);
            } else {
                throw new Error('Unsupported encryption algorithm: ' + encryptionInfo.algorithm);
            }
        }
        
        async function deriveKeyFromPassword(password, salt) {
            // Convert password to an array buffer
            const passwordBuffer = new TextEncoder().encode(password);
            
            // Import the password as a key
            const baseKey = await window.crypto.subtle.importKey(
                'raw',
                passwordBuffer,
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
            );
            
            // Derive a key using PBKDF2
            return window.crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: PBKDF2_CONFIG.ITERATIONS,
                    hash: PBKDF2_CONFIG.HASH
                },
                baseKey,
                { name: AES_CONFIG.MODE, length: AES_CONFIG.KEY_LENGTH },
                true,
                ['encrypt', 'decrypt']
            );
        }
        
        async function encryptWithDerivedKey(key, data, iv) {
            return window.crypto.subtle.encrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                key,
                data
            );
        }
        
        async function decryptWithDerivedKey(key, data, iv) {
            return window.crypto.subtle.decrypt(
                {
                    name: AES_CONFIG.MODE,
                    iv: iv,
                    tagLength: AES_CONFIG.TAG_LENGTH
                },
                key,
                data
            );
        }
        
        async function importAESKey(keyData) {
            return window.crypto.subtle.importKey(
                'raw',
                keyData,
                {
                    name: AES_CONFIG.MODE,
                    length: AES_CONFIG.KEY_LENGTH 
                },
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        async function importRSAPublicKey(keyData, keySize) {
            return window.crypto.subtle.importKey(
                'spki',
                keyData,
                {
                    name: RSA_CONFIG.ALGORITHM,
                    hash: RSA_CONFIG.HASH
                },
                false,
                ['encrypt']
            );
        }
        
        async function importRSAPrivateKey(keyData, keySize) {
            return window.crypto.subtle.importKey(
                'pkcs8',
                keyData,
                {
                    name: RSA_CONFIG.ALGORITHM,
                    hash: RSA_CONFIG.HASH
                },
                false,
                ['decrypt']
            );
        }
        
        async function importECCPublicKey(keyData, curve) {
            return window.crypto.subtle.importKey(
                'spki',
                keyData,
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                false,
                []
            );
        }
        
        async function importECCPrivateKey(keyData, curve) {
            return window.crypto.subtle.importKey(
                'pkcs8',
                keyData,
                {
                    name: 'ECDH',
                    namedCurve: curve
                },
                false,
                ['deriveKey', 'deriveBits']
            );
        }
        
        // Database Helper Functions
        async function saveToDatabase(storeName, data) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        async function getFromDatabase(storeName, key) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function getAllFromDatabase(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function clearDatabase(storeName) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        window.exportKey = exportKey;
        window.exportPrivateKey = exportPrivateKey;
        window.deleteKey = deleteKey;

        // PWA Support
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');
        const installContainer = document.getElementById('installContainer');
        const installStatus = document.getElementById('installStatus');

        // Initially disable the install button until we know it's available
        if (installBtn) {
            installBtn.disabled = true;
        }

        // Handle PWA installation
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67+ from automatically showing the prompt
            e.preventDefault();
            
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Enable the install button
            if (installBtn) {
                installBtn.disabled = false;
                const noteElement = installContainer.querySelector('.install-note');
                if (noteElement) {
                    noteElement.style.display = 'none';
                }
                showStatus('installStatus', 'Installation is now available!', 'success');
            }
        });

        // Install button click handler
        if (installBtn) {
            installBtn.addEventListener('click', async () => {
                if (!deferredPrompt) {
                    showStatus('installStatus', 'Installation not available in this browser or app is already installed', 'warning');
                    return;
                }
                
                // Show the install prompt
                deferredPrompt.prompt();
                
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to install prompt: ${outcome}`);
                
                if (outcome === 'accepted') {
                    showStatus('installStatus', 'Lemonade has been installed successfully!', 'success');
                } else {
                    showStatus('installStatus', 'Installation was canceled', 'warning');
                }
                
                // Clear the saved prompt since it can't be used again
                deferredPrompt = null;
                installBtn.disabled = true;
            });
        }

        // Check if already installed
        window.addEventListener('appinstalled', () => {
            console.log('Lemonade was installed');
            deferredPrompt = null;
            if (installBtn) {
                installBtn.disabled = true;
            }
            showStatus('installStatus', 'Lemonade has been installed successfully!', 'success');
        });

        // Register service worker
        if ('serviceWorker' in navigator && (window.location.protocol === 'https:' || 
            window.location.hostname === 'localhost' || 
            window.location.hostname === '127.0.0.1')) {
            
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('sw.js')
                    .then(function(registration) {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(function(error) {
                        console.error('Service Worker registration failed:', error);
                        showStatus('installStatus', 'Service Worker registration failed. PWA features unavailable.', 'warning');
                    });
            });
        } else {
            console.log('Service Workers not supported or not in secure context');
            if (installStatus) {
                if (window.location.protocol === 'file:') {
                    showStatus('installStatus', 'PWA installation requires HTTPS. You are viewing this file locally.', 'warning');
                } else {
                    showStatus('installStatus', 'Your browser does not support PWA installation features.', 'warning');
                }
            }
        }

        // Check display mode
        if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('App is already running in standalone mode (installed)');
            if (installStatus) {
                showStatus('installStatus', 'Lemonade is running as an installed app', 'success');
            }
        }

        // File handling variables
        let encryptFileData = null;
        let encryptFileName = '';
        let decryptFileData = null;
        let decryptFileName = '';

        // Setup file drop areas
        document.addEventListener('DOMContentLoaded', function() {
            // Setup file input elements
            const encryptFileInput = document.getElementById('encryptFileInput');
            const encryptBrowseBtn = document.getElementById('encryptBrowseBtn');
            const encryptFileInfo = document.getElementById('encryptFileInfo');
            const encryptFileNameEl = document.getElementById('encryptFileName');
            const removeEncryptFile = document.getElementById('removeEncryptFile');
                
            // Setup decrypt file elements
            const decryptFileInput = document.getElementById('decryptFileInput');
            const decryptBrowseBtn = document.getElementById('decryptBrowseBtn');
            const decryptFileInfo = document.getElementById('decryptFileInfo');
            const decryptFileNameEl = document.getElementById('decryptFileName');
            const removeDecryptFile = document.getElementById('removeDecryptFile');
            
            // Download buttons
            const downloadEncryptedBtn = document.getElementById('downloadEncryptedBtn');
            const downloadDecryptedBtn = document.getElementById('downloadDecryptedBtn');
            
            // Encrypt file area event listeners            
            encryptBrowseBtn.addEventListener('click', () => {
                encryptFileInput.click();
            });
            
            encryptFileInput.addEventListener('change', (e) => {
                handleEncryptFileSelect(e.target.files);
            });
            
            removeEncryptFile.addEventListener('click', () => {
                clearEncryptFile();
            });
            
            // Decrypt file area event listeners            
            decryptBrowseBtn.addEventListener('click', () => {
                decryptFileInput.click();
            });
            
            decryptFileInput.addEventListener('change', (e) => {
                handleDecryptFileSelect(e.target.files);
            });
            
            removeDecryptFile.addEventListener('click', () => {
                clearDecryptFile();
            });

            // Create the key file input element on page load
            createKeyFileInput();
            
            // Download file event listeners
            downloadEncryptedBtn.addEventListener('click', downloadEncryptedFile);
            downloadDecryptedBtn.addEventListener('click', downloadDecryptedFile);

            document.getElementById('encryptBtn').addEventListener('click', function() {
            // Clear any previous decrypted binary data
            window.decryptedBinaryData = null;
        });

            // Set up confirm and cancel buttons
            document.getElementById('passwordModalConfirm').addEventListener('click', confirmPasswordModal);
            document.getElementById('passwordModalCancel').addEventListener('click', cancelPasswordModal);
            
            // Set up password strength meter
            document.getElementById('passwordModalInput').addEventListener('input', updateModalPasswordStrength);
            
            // Allow Enter key to confirm
            document.getElementById('passwordModalInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    confirmPasswordModal();
                }
            });
            
            // Allow Escape key to cancel
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('passwordModal').style.display === 'flex') {
                    cancelPasswordModal();
                }
            });
        });

        // File handling functions
        function handleEncryptFileSelect(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            encryptFileName = file.name;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                encryptFileData = e.target.result;
                document.getElementById('encryptMessage').value = `File: ${encryptFileName} (${formatFileSize(file.size)})`;
                document.getElementById('encryptFileInfo').style.display = 'flex';
                document.getElementById('encryptFileName').textContent = encryptFileName;
            };
            reader.readAsArrayBuffer(file);
        }

        function handleDecryptFileSelect(files) {
            if (files.length === 0) return;

            const file = files[0];
            decryptFileName = file.name;

            const textReader = new FileReader();
            textReader.onload = function(textEvent) {
                const textContent = textEvent.target.result;
                document.getElementById('encryptedMessage').value = textContent;
                decryptFileData = null; // Not treating as binary
                document.getElementById('decryptFileInfo').style.display = 'flex';
                document.getElementById('decryptFileName').textContent = decryptFileName;
                showStatus('decryptStatus', 'Encrypted file loaded. Select key and enter OBF key if needed.', 'success');
            };

            textReader.onerror = function() {
                // Error reading as text
                showStatus('decryptStatus', 'Unable to read the file.', 'error');
            };

            // Read the file as text
            textReader.readAsText(file);
        }

        function clearEncryptFile() {
            encryptFileData = null;
            encryptFileName = '';
            document.getElementById('encryptMessage').value = '';
            document.getElementById('encryptFileInfo').style.display = 'none';
            document.getElementById('encryptFileInput').value = '';
        }

        function clearDecryptFile() {
            decryptFileData = null;
            decryptFileName = '';
            document.getElementById('encryptedMessage').value = '';
            document.getElementById('decryptFileInfo').style.display = 'none';
            document.getElementById('decryptFileInput').value = '';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function generateRandomFileName(length = 6) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

    </script>
<div id="passwordModal" class="modal">
    <div class="modal-content">
        <h3 id="passwordModalTitle">Enter Password</h3>
        <p id="passwordModalMessage">Please enter a password to continue:</p>
        <div class="form-group">
            <input type="password" id="passwordModalInput" placeholder="Enter password">
            <div id="passwordModalStrength" class="password-strength"></div>
            <div id="passwordModalFeedback" class="password-feedback"></div>
        </div>
        <div class="btn-group">
            <button id="passwordModalConfirm" class="btn-primary">Confirm</button>
            <button id="passwordModalCancel" class="btn-secondary">Cancel</button>
        </div>
    </div>
</div>
</body>
</html>
